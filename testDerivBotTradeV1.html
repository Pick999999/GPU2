<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Deriv Accumulator Bot (Trade Edition)</title>
    <!-- Project Dependencies -->
    <script src="MultiAssetBundle.js"></script>
    <script src="https://unpkg.com/lightweight-charts@4.2.1/dist/lightweight-charts.standalone.production.js"></script>

    <style>
        body {
            font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
        }

        .container {
            background-color: #252526;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            width: 100%;
            max-width: 2800px;
            border: 1px solid #3c3c3c;
        }

        h1 {
            color: #4ec9b0;
            text-align: center;
            margin-bottom: 25px;
            font-size: 24px;
        }

        .section-title {
            color: #569cd6;
            font-size: 18px;
            border-bottom: 1px solid #3c3c3c;
            padding-bottom: 5px;
            margin-bottom: 15px;
            margin-top: 20px;
        }

        .form-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .full-width {
            grid-column: span 2;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #d4d4d4;
            font-weight: 500;
        }

        select,
        input[type="number"],
        input[type="text"],
        input[type="password"] {
            width: 100%;
            padding: 10px;
            background-color: #3c3c3c;
            border: 1px solid #555;
            color: white;
            border-radius: 6px;
            font-size: 14px;
            box-sizing: border-box;
        }

        select:focus,
        input:focus {
            outline: none;
            border-color: #4ec9b0;
            box-shadow: 0 0 5px rgba(78, 201, 176, 0.3);
        }

        .growth-options {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
        }

        .growth-option {
            background-color: #3c3c3c;
            border: 1px solid #555;
            padding: 10px;
            text-align: center;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
        }

        .growth-option.selected {
            background-color: #4ec9b0;
            color: #1e1e1e;
            border-color: #4ec9b0;
            font-weight: bold;
        }

        .growth-option:hover:not(.selected) {
            background-color: #444;
        }

        button {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition:
                transform 0.1s,
                box-shadow 0.2s;
            margin-top: 10px;
        }

        button.primary {
            background: linear-gradient(135deg, #0e639c, #1177bb);
            color: white;
        }

        button.primary:hover {
            background: linear-gradient(135deg, #1177bb, #2299dd);
            box-shadow: 0 4px 12px rgba(17, 119, 187, 0.4);
        }

        button.stop {
            background: linear-gradient(135deg, #b91c1c, #ef4444);
            color: white;
            display: none;
        }

        button.stop:hover {
            background: linear-gradient(135deg, #ef4444, #f87171);
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);
        }

        #status {
            margin-top: 20px;
            padding: 15px;
            border-radius: 6px;
            display: none;
            font-size: 14px;
        }

        .status-success {
            background-color: rgba(76, 175, 80, 0.1);
            border: 1px solid #4caf50;
            color: #4caf50;
        }

        .status-error {
            background-color: rgba(244, 67, 54, 0.1);
            border: 1px solid #f44336;
            color: #f44336;
        }

        .status-info {
            background-color: rgba(33, 150, 243, 0.1);
            border: 1px solid #2196f3;
            color: #2196f3;
        }

        /* Tabs */
        .tabs {
            display: flex;
            margin-top: 25px;
            background-color: #333;
            border-radius: 6px 6px 0 0;
            overflow: hidden;
        }

        .tab-btn {
            flex: 1;
            padding: 12px;
            background-color: #333;
            color: #aaa;
            border: none;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            font-weight: 500;
            border-radius: 0;
            margin-top: 0;
        }

        .tab-btn:hover {
            background-color: #444;
            color: #fff;
        }

        .tab-btn.active {
            background-color: #252526;
            color: #4ec9b0;
            border-bottom: 2px solid #4ec9b0;
        }

        .tab-content {
            display: none;
            padding: 20px;
            background-color: #2d2d2d;
            border-radius: 0 0 6px 6px;
            border: 1px solid #3c3c3c;
            border-top: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Tables & Data */
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }

        th,
        td {
            border: 1px solid #3c3c3c;
            padding: 8px;
            text-align: center;
        }

        th {
            background-color: #333;
            color: #ccc;
        }

        .td-win {
            color: #4caf50;
        }

        .td-loss {
            color: #f44336;
        }

        .summary-stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 15px;
            background: #333;
            padding: 10px;
            border-radius: 6px;
        }

        .summary-item strong {
            display: block;
            font-size: 18px;
        }

        pre {
            background-color: #1e1e1e;
            padding: 15px;
            border-radius: 6px;
            overflow-x: auto;
            color: #9cdcfe;
            font-family: "Consolas", "Courier New", monospace;
            font-size: 13px;
            margin: 0;
        }

        .json-key {
            color: #9cdcfe;
        }

        .json-string {
            color: #ce9178;
        }

        .json-number {
            color: #b5cea8;
        }

        .json-boolean {
            color: #569cd6;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>Deriv Accumulator Bot (Trade Edition)</h1>

        <!-- Authentication -->
        <div id="authSection">
            <div class="form-group">
                <label for="apiToken">Deriv API Token</label>
                <input type="password" id="apiToken" placeholder="Enter your API Token" value="lt5UMO6bNvmZQaR" />
            </div>
            <button class="primary" onclick="connectAndAuthorize()">
                üîê Connect
            </button>
        </div>

        <!-- Chart Tabs -->
        <div class="tabs" style="justify-content: flex-start; margin-bottom: 5px">
            <button class="tab-btn active" onclick="switchChartTab('tick')">
                Tick Line
            </button>
            <button class="tab-btn" id="candleTabBtn" onclick="switchChartTab('candle')">
                Candles (10s)
            </button>
        </div>

        <!-- Chart Section -->
        <div id="chartSection" style="
                    margin-bottom: 20px;
                    border: 1px solid #3c3c3c;
                    border-radius: 6px;
                    overflow: hidden;
                    background: #1e1e1e;
                ">
            <div id="tickChartContainer" style="width: 100%; height: 600px"></div>
            <div id="candleChartContainer" style="width: 100%; height: 600px; display: none"></div>
        </div>

        <!-- Trade Dashboard (Real-time) -->
        <div id="tradeDashboard" style="
                    display: none;
                    grid-template-columns: repeat(4, 1fr);
                    gap: 8px;
                    margin-bottom: 20px;
                    padding: 12px;
                    background: #252526;
                    border: 1px solid #3c3c3c;
                    border-radius: 6px;
                    font-family: &quot;Segoe UI&quot;, monospace;
                    font-size: 13px;
                ">
            <div class="dash-item">
                <div style="color: #888; font-size: 11px">Current Spot</div>
                <div id="dashSpot" style="font-size: 15px; font-weight: 600; color: #fff">
                    --
                </div>
            </div>
            <div class="dash-item">
                <div style="color: #888; font-size: 11px">Safety Gap</div>
                <div id="dashGap" style="
                            font-size: 15px;
                            font-weight: 600;
                            color: #4caf50;
                        ">
                    --
                </div>
                <div id="dashGapPct" style="font-size: 11px; color: #aaa">
                    (--%)
                </div>
            </div>
            <div class="dash-item">
                <div style="color: #888; font-size: 11px">Velocity</div>
                <div id="dashVel" style="font-size: 15px; font-weight: 600">
                    --
                </div>
            </div>
            <div class="dash-item">
                <div style="color: #888; font-size: 11px">Profit</div>
                <div id="dashProfit" style="font-size: 15px; font-weight: 600">
                    --
                </div>
            </div>

            <div class="dash-item">
                <div style="color: #888; font-size: 11px">Balance (Est.)</div>
                <div id="dashBalance" style="font-size: 15px; font-weight: 600; color: #fff">
                    --
                </div>
            </div>

            <!-- New: Lot No -->
            <div class="dash-item">
                <div style="color: #888; font-size: 11px">Lot No (Today)</div>
                <div id="dashLotNo" style="font-size: 14px; font-weight: 600; color: #ccc">
                    --
                </div>
            </div>

            <div class="dash-item" style="grid-column: span 3; margin-top: 5px">
                <div id="dashStatus" style="
                            background: #333;
                            color: #aaa;
                            padding: 4px 8px;
                            border-radius: 4px;
                            text-align: center;
                            font-weight: bold;
                            letter-spacing: 1px;
                        ">
                    WAITING FOR TRADE...
                </div>
                <!-- Action Description -->
                <div id="dashAction" style="
                    margin-top: 5px; 
                    font-size: 12px; 
                    text-align: center; 
                    color: #bbb; 
                    font-style: italic;">
                    (bot is idle)
                </div>
            </div>
        </div>

        <!-- Chart Settings -->
        <div style="
                    margin-bottom: 15px;
                    padding: 15px;
                    background: #252526;
                    border: 1px solid #3c3c3c;
                    border-radius: 6px;
                ">
            <div style="
                        display: flex;
                        align-items: center;
                        gap: 15px;
                        flex-wrap: wrap;
                    ">
                <div style="flex: 0 0 auto">
                    <label style="
                                margin-bottom: 5px;
                                display: block;
                                font-size: 13px;
                            ">
                        ‚öôÔ∏è Candle Interval (seconds)
                    </label>
                    <input type="number" id="candleInterval" value="10" min="1" max="300" step="1"
                        style="width: 100px; padding: 8px" onchange="updateCandleInterval()" />
                </div>
                <div style="flex: 0 0 auto; padding-top: 20px">
                    <button onclick="updateCandleInterval()" style="
                                background-color: #4ec9b0;
                                color: #1e1e1e;
                                border: none;
                                padding: 8px 15px;
                                border-radius: 4px;
                                cursor: pointer;
                                font-weight: 500;
                            ">
                        Apply
                    </button>
                </div>
            </div>
        </div>

        <!-- Tick Data Display -->
        <div style="
                    margin-bottom: 15px;
                    padding: 15px;
                    background: #252526;
                    border: 1px solid #3c3c3c;
                    border-radius: 6px;
                ">
            <div style="
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        margin-bottom: 10px;
                    ">
                <label style="
                            margin: 0;
                            font-size: 14px;
                            color: #4ec9b0;
                            font-weight: 600;
                        ">
                    üìä Tick Data Storage (Last 100 ticks)
                </label>
                <div style="display: flex; gap: 8px">
                    <button onclick="exportTickData()" style="
                                background-color: #4ec9b0;
                                color: #1e1e1e;
                                border: none;
                                padding: 6px 12px;
                                border-radius: 4px;
                                cursor: pointer;
                                font-size: 12px;
                                font-weight: 500;
                            ">
                        üì• Export
                    </button>
                    <button onclick="importTickData()" style="
                                background-color: #569cd6;
                                color: white;
                                border: none;
                                padding: 6px 12px;
                                border-radius: 4px;
                                cursor: pointer;
                                font-size: 12px;
                                font-weight: 500;
                            ">
                        üì§ Import
                    </button>
                    <button onclick="clearTickData()" style="
                                background-color: #d32f2f;
                                color: white;
                                border: none;
                                padding: 6px 12px;
                                border-radius: 4px;
                                cursor: pointer;
                                font-size: 12px;
                            ">
                        üóëÔ∏è Clear Data
                    </button>
                </div>
            </div>
            <textarea id="tickDataArea" readonly style="
                        width: 100%;
                        height: 150px;
                        background-color: #1e1e1e;
                        color: #d4d4d4;
                        border: 1px solid #555;
                        border-radius: 4px;
                        padding: 10px;
                        font-family:
                            &quot;Consolas&quot;, &quot;Courier New&quot;,
                            monospace;
                        font-size: 12px;
                        resize: vertical;
                        box-sizing: border-box;
                    ">
No tick data yet...</textarea>
        </div>



        <!-- Bot Configuration -->
        <div id="configSection" style="display: none; opacity: 0.5; pointer-events: none">
            <div class="section-title">Bot Configuration</div>

            <div class="form-section">
                <!-- Asset -->
                <div class="form-group full-width">
                    <label for="assetSelect">Underlying Asset</label>
                    <select id="assetSelect"></select>
                </div>

                <!-- Growth Rate -->
                <div class="form-group full-width">
                    <label>Growth Rate</label>
                    <div class="growth-options" id="growthOptions">
                        <div class="growth-option" data-value="0.01">
                            1%
                        </div>
                        <div class="growth-option" data-value="0.02">
                            2%
                        </div>
                        <div class="growth-option" data-value="0.03">
                            3%
                        </div>
                        <div class="growth-option" data-value="0.04">
                            4%
                        </div>
                        <div class="growth-option" data-value="0.05">
                            5%
                        </div>
                    </div>
                    <input type="hidden" id="growthRate" value="" />
                </div>

                <!-- Stake & TP -->
                <div class="form-group">
                    <label>Stake (USD)</label>
                    <input type="number" id="stakeAmount" value="10" min="1" step="0.1" />
                </div>
                <div class="form-group">
                    <label>Take Profit (USD)</label>
                    <input type="number" id="takeProfit" value="0.1" min="0.1" step="0.1" />
                </div>

                <!-- Loop Config -->
                <div class="form-group">
                    <label>Loop Count (N)</label>
                    <input type="number" id="loopCount" value="15" min="1" />
                </div>
                <div class="form-group">
                    <label>Delay (Seconds)</label>
                    <input type="number" id="loopDelay" value="3" min="1" />
                </div>

                <!-- SAFETY FIRST: Risk Management -->
                <div class="full-width section-title" style="
                            margin-top: 10px;
                            background: #f44336;
                            color: white;
                            padding: 8px;
                        ">
                    üõ°Ô∏è RISK MANAGEMENT (SAFETY FIRST)
                </div>

                <div class="form-group">
                    <label>Max Daily Loss (USD) ‚ö†Ô∏è
                        <span style="color: #ff9900">DISABLED</span>
                        <div style="
                                    font-size: 11px;
                                    color: #ff9900;
                                    font-weight: normal;
                                    margin-top: 2px;
                                ">
                            ‚ö†Ô∏è ‡∏ü‡∏µ‡πÄ‡∏à‡∏≠‡∏£‡πå‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô - Bot
                            ‡∏à‡∏∞‡πÄ‡∏ó‡∏£‡∏î‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡∏™‡∏ô‡πÉ‡∏à Daily Loss Limit
                        </div>
                    </label>
                    <input type="number" id="maxDailyLoss" value="50" min="10" step="10" />
                </div>

                <div class="form-group">
                    <label>Max Session Loss (USD)
                        <div style="
                                    font-size: 11px;
                                    color: #999;
                                    font-weight: normal;
                                    margin-top: 2px;
                                ">
                            ‡∏´‡∏¢‡∏∏‡∏î Lot ‡∏ô‡∏µ‡πâ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô‡∏ñ‡∏∂‡∏á‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ô‡∏µ‡πâ
                        </div>
                    </label>
                    <input type="number" id="maxSessionLoss" value="20" min="5" step="5" />
                </div>

                <div class="form-group">
                    <label>Max Consecutive Losses
                        <div style="
                                    font-size: 11px;
                                    color: #999;
                                    font-weight: normal;
                                    margin-top: 2px;
                                ">
                            ‡∏´‡∏¢‡∏∏‡∏î‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÅ‡∏û‡πâ‡∏ï‡∏¥‡∏î‡∏Å‡∏±‡∏ô‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ô‡∏µ‡πâ
                        </div>
                    </label>
                    <input type="number" id="maxConsecLoss" value="5" min="2" step="1" />
                </div>

                <div class="form-group">
                    <label>Reduce Stake on Loss (%)
                        <div style="
                                    font-size: 11px;
                                    color: #999;
                                    font-weight: normal;
                                    margin-top: 2px;
                                ">
                            ‡∏•‡∏î Stake ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÅ‡∏û‡πâ (0 = ‡πÑ‡∏°‡πà‡∏•‡∏î, 50 = ‡∏•‡∏î 50%)
                        </div>
                    </label>
                    <input type="number" id="reducePct" value="30" min="0" max="90" step="10" />
                </div>

                <div class="form-group">
                    <label>Min Stake After Reduce (USD)
                        <div style="
                                    font-size: 11px;
                                    color: #999;
                                    font-weight: normal;
                                    margin-top: 2px;
                                ">
                            Stake ‡∏ï‡πà‡∏≥‡∏™‡∏∏‡∏î‡∏´‡∏•‡∏±‡∏á‡∏•‡∏î‡πÅ‡∏•‡πâ‡∏ß
                        </div>
                    </label>
                    <input type="number" id="minStake" value="1" min="0.5" step="0.5" />
                </div>

                <!-- Panic Sell Config -->
                <div class="full-width section-title" style="margin-top: 10px">
                    Loss Protection (Panic Sell)
                </div>
                <div class="form-group">
                    <label>Min Gap % (Panic Level)
                        <div style="
                                    font-size: 11px;
                                    color: #999;
                                    font-weight: normal;
                                    margin-top: 2px;
                                ">
                            ‡∏ñ‡πâ‡∏≤‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏ï‡πà‡∏≥‡∏Å‡∏ß‡πà‡∏≤‡∏Ñ‡πà‡∏≤‡∏ô‡∏µ‡πâ (% ‡∏Ç‡∏≠‡∏á‡∏ï‡∏≠‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°)
                            ‡πÉ‡∏´‡πâ‡∏Ç‡∏≤‡∏¢‡∏ó‡∏¥‡πâ‡∏á
                        </div>
                    </label>
                    <input type="number" id="panicPct" value="40" min="1" max="100" />
                </div>
                <div class="form-group">
                    <label>Max Velocity % (Crash Detect)
                        <div style="
                                    font-size: 11px;
                                    color: #999;
                                    font-weight: normal;
                                    margin-top: 2px;
                                ">
                            ‡∏ñ‡πâ‡∏≤‡∏Å‡∏£‡∏≤‡∏ü‡∏û‡∏∏‡πà‡∏á‡πÄ‡∏Ç‡πâ‡∏≤‡∏´‡∏≤ Barrier ‡πÄ‡∏£‡πá‡∏ß‡πÄ‡∏Å‡∏¥‡∏ô‡∏Ñ‡πà‡∏≤‡∏ô‡∏µ‡πâ (% ‡πÉ‡∏ô 1
                            Tick) ‡πÉ‡∏´‡πâ‡∏Ç‡∏≤‡∏¢‡∏ó‡∏¥‡πâ‡∏á
                        </div>
                    </label>
                    <input type="number" id="velocityPct" value="30" min="1" max="100" />
                </div>

                <!-- Chart Indicators (Tick Chart Only) -->
                <div class="full-width section-title" style="margin-top: 10px">
                    Chart Indicators (Tick Only)
                </div>
                <div class="form-group">
                    <label>Type</label>
                    <select id="indicatorType">
                        <option value="HMA" selected>
                            HMA (Hull - Faster)
                        </option>
                        <option value="EMA">
                            EMA (Exponential - Smooth)
                        </option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Period</label>
                    <input type="number" id="indicatorPeriod" value="14" min="2" max="200" />
                </div>
            </div>

            <button class="primary" id="btnStart" onclick="startBot()">
                ‚ñ∂ Start Bot (New Lot)
            </button>
            <button class="stop" id="btnStop" onclick="stopBot()">
                ‚èπ Stop Bot
            </button>
        </div>

        <div id="status"></div>

        <!-- Audio -->
        <audio id="applauseSound" src="applause.mp3"></audio>

        <!-- Tabs -->
        <div class="tabs" id="mainTabs">
            <button class="tab-btn active" onclick="switchTab('session')">
                Session Report
            </button>
            <button class="tab-btn" onclick="switchTab('headTrade')">
                HeadTrade Info
            </button>
        </div>

        <!-- Tab Content: Session Report -->
        <div id="tab-session" class="tab-content active">
            <div class="summary-stats">
                <div class="summary-item">
                    Loop: <strong id="sumTotal">0</strong>
                </div>
                <div class="summary-item" style="color: #4caf50">
                    Win: <strong id="sumWin">0</strong>
                </div>
                <div class="summary-item" style="color: #f44336">
                    Loss: <strong id="sumLoss">0</strong>
                </div>
                <div class="summary-item">
                    Lot Profit: <strong id="sumPnl">0.00</strong>
                </div>
            </div>
            <table id="logTable">
                <thead>
                    <tr>
                        <th>#</th>
                        <th>Time</th>
                        <th>Asset</th>
                        <th>Result</th>
                        <th>Profit</th>
                        <th>Balance (Lot)</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>

        <!-- Tab Content: HeadTrade -->
        <div id="tab-headTrade" class="tab-content">
            <div style="text-align: right; margin-bottom: 10px">
                <button onclick="clearHistory()" style="
                            background-color: #d32f2f;
                            color: white;
                            width: auto;
                            padding: 8px 15px;
                            font-size: 12px;
                        ">
                    üóëÔ∏è Clear Today's History
                </button>
            </div>
            <div id="headTradeDisplay">
                <p>Waiting for trade data...</p>
            </div>
            <div class="section-title" style="margin-top: 20px">
                DetailTrade (JSON)
            </div>
            <pre id="detailTradeJson"></pre>
        </div>
    </div>

    <script>
        // Global State
        let api = null;
        let isAuthorized = false;
        let isBotRunning = false;
        let currentLoop = 0;
        let totalLoops = 0;
        let delaySeconds = 0;
        let currentContractId = null;

        // SAFETY: Risk Management State
        let riskConfig = {
            maxDailyLoss: 50,
            maxSessionLoss: 20,
            maxConsecLoss: 5,
            reducePct: 30,
            minStake: 1,
        };
        let consecutiveLosses = 0;
        let baseStake = 10;
        let currentStake = 10;

        // Chart State
        let tickChart = null;
        let candleChart = null;

        // Series
        let lineSeries = null; // In tickChart
        let indicatorSeries = null; // In tickChart
        let candleSeries = null; // In candleChart

        let highBarrierLine = null;
        let lowBarrierLine = null;
        let entryPriceLine = null;

        // Candle Chart Barriers & Markers
        let candleHighBarrierLine = null;
        let candleLowBarrierLine = null;
        let candleEntryPriceLine = null;
        let lossMarkerSeries = null;

        // Track current trade barriers for loss detection
        let currentTradeBarriers = {
            high: null,
            low: null,
            contractId: null,
            entrySpot: null,
        };

        // Track current trade profit for OHLC
        let currentTradeProfit = 0;

        let tickSubscriptionId = null;
        let currentSymbol = "R_100"; // Default

        // Indicator Data
        let tickDataBuffer = []; // Store raw prices {time, value} for calc

        // Data Models
        let appData = {
            currentLotNo: 0,
            dailyBalance: 0,
            totalTradesToday: 0,
        };

        let currentHeadTrade = {};
        let currentDetailTrade = [];
        let sessionStats = { wins: 0, losses: 0, pnl: 0 };
        let dailyPnL = 0; // Track daily P&L

        // 1. Initial Setup
        async function init() {
            checkNewDay();
            loadAppData();
            loadTickDataFromStorage();

            const defaultRate = document.querySelector(
                '.growth-option[data-value="0.03"]',
            );
            if (defaultRate) defaultRate.click();

            // Wait for populateAssetSelect to be called after auth, or call it here if needed?
            // Actually populateAssetSelect is called in init() too? No, it's called with NULL.
            // Let's keep it as is.
            populateAssetSelect();

            document
                .getElementById("assetSelect")
                .addEventListener("change", (e) => {
                    subscribeTicks(e.target.value);
                });
        }

        // Feature 1: Check New Day & LotNo Management
        function checkNewDay() {
            const today = new Date().toLocaleDateString("th-TH");
            const storedDate = localStorage.getItem("derivBot_date");

            if (storedDate !== today) {
                // New Day Reset
                localStorage.setItem("derivBot_date", today);
                localStorage.setItem("derivBot_lotNo", "0");
                localStorage.setItem("derivBot_dailyBalance", "0");
                localStorage.setItem("derivBot_totalTrades", "0");
                console.log(
                    "New Day detected. Resetting LotNo and Balance.",
                );
            }
        }

        function loadAppData() {
            appData.currentLotNo = parseInt(
                localStorage.getItem("derivBot_lotNo") || "0",
            );
            appData.dailyBalance = parseFloat(
                localStorage.getItem("derivBot_dailyBalance") || "0",
            );
            appData.totalTradesToday = parseInt(
                localStorage.getItem("derivBot_totalTrades") || "0",
            );
        }

        function saveAppData() {
            localStorage.setItem("derivBot_lotNo", appData.currentLotNo);
            localStorage.setItem(
                "derivBot_dailyBalance",
                appData.dailyBalance.toString(),
            );
            localStorage.setItem(
                "derivBot_totalTrades",
                appData.totalTradesToday,
            );
        }

        async function populateAssetSelect(derivApiInstance = null) {
            const assetSelect = document.getElementById("assetSelect");
            assetSelect.innerHTML =
                '<option value="" disabled selected>Loading...</option>';

            try {
                let activeSymbols = [];
                if (derivApiInstance) {
                    activeSymbols =
                        await derivApiInstance.getActiveSymbols();
                } else {
                    const tempApi = new DerivAPI("1089");
                    await tempApi.connect();
                    activeSymbols = await tempApi.getActiveSymbols();
                    tempApi.disconnect();
                }

                const volatilityIndices = activeSymbols
                    .filter(
                        (s) =>
                            (s.market === "synthetic_index" &&
                                s.submarket === "random_index") ||
                            s.submarket === "random_index",
                    )
                    .sort((a, b) => a.symbol.localeCompare(b.symbol));

                assetSelect.innerHTML = "";
                volatilityIndices.forEach((asset) => {
                    const option = document.createElement("option");
                    option.value = asset.symbol;
                    option.textContent = `${asset.symbol} - ${asset.display_name}`;
                    assetSelect.appendChild(option);
                });

                if (volatilityIndices.some((a) => a.symbol === "R_100"))
                    assetSelect.value = "R_100";
            } catch (e) {
                console.warn("Asset fetch failed", e);
                assetSelect.innerHTML =
                    '<option value="R_100">Volatility 100 (1s)</option>';
            }
        }

        // 2. Auth
        async function connectAndAuthorize() {
            const token = document.getElementById("apiToken").value.trim();
            if (!token) return showStatus("Enter API Token", "error");

            try {
                if (api) api.disconnect();
                api = new DerivAPI("1089");

                const originalHandle = api.handleMessage.bind(api);
                api.handleMessage = function (data) {
                    originalHandle(data);
                    if (
                        data.msg_type &&
                        this.messageHandlers.has(data.msg_type)
                    ) {
                        this.messageHandlers.get(data.msg_type)(data);
                    }
                };

                await api.connect();
                const authResp = await api.sendAndWait({
                    authorize: token,
                });
                if (authResp.error) throw new Error(authResp.error.message);

                isAuthorized = true;
                showStatus("‚úÖ Connected. Ready to configure.", "success");

                const configDiv = document.getElementById("configSection");
                configDiv.style.display = "block";
                configDiv.style.opacity = "1";
                configDiv.style.pointerEvents = "auto";
                document.getElementById("authSection").style.display =
                    "none";

                // Init Chart
                document.getElementById("chartSection").style.display =
                    "block";
                initChart();

                await populateAssetSelect(api);

                // ‚úÖ OHLC Listener (Real-time Candle Updates)
                api.on("ohlc", (data) => {
                    if (data.ohlc && data.ohlc.id === tickSubscriptionId) {
                        const newCandle = {
                            time: data.ohlc.epoch,
                            open: data.ohlc.open,
                            high: data.ohlc.high,
                            low: data.ohlc.low,
                            close: data.ohlc.close,
                        };

                        console.log("üìä OHLC Update:", {
                            time: new Date(
                                data.ohlc.epoch * 1000,
                            ).toLocaleString(),
                            O: data.ohlc.open,
                            H: data.ohlc.high,
                            L: data.ohlc.low,
                            C: data.ohlc.close,
                            granularity: data.ohlc.granularity + "s",
                        });

                        // Update Candle Chart
                        if (candleSeries) {
                            candleSeries.update(newCandle);
                        }

                        // Update Line Chart (‡πÉ‡∏ä‡πâ close price)
                        const tick = {
                            time: parseInt(data.ohlc.epoch),
                            value: parseFloat(data.ohlc.close),
                            epoch: parseInt(data.ohlc.epoch),
                            profit: currentTradeProfit,
                        };

                        if (lineSeries) lineSeries.update(tick);

                        // Save to storage
                        saveTickDataToStorage(tick);

                        // Buffer
                        tickDataBuffer.push(tick);
                        if (tickDataBuffer.length > 2000)
                            tickDataBuffer.shift();

                        // Update indicators
                        updateIndicatorChart();
                    }
                });

                // Tick Listener (Fallback for regular ticks if needed)
                api.on("tick", (data) => {
                    if (data.tick && data.tick.id === tickSubscriptionId) {
                        const tick = {
                            time: parseInt(data.tick.epoch),
                            value: parseFloat(data.tick.quote),
                            epoch: parseInt(data.tick.epoch),
                        };

                        // Save tick to storage
                        saveTickDataToStorage(tick);

                        // Update Tick Chart
                        if (lineSeries) lineSeries.update(tick);
                        if (indicatorSeries) updateIndicatorChart(tick);

                        // Update Candle Chart (Synthetic)
                        if (candleSeries) updateSyntheticCandleLive(tick);

                        // Buffer
                        tickDataBuffer.push(tick);
                        if (tickDataBuffer.length > 2000)
                            tickDataBuffer.shift();

                        // Force logic update (indicators)
                        updateIndicatorChart();
                    }
                });

                // Susbcribe to ticks for default asset
                subscribeTicks(
                    document.getElementById("assetSelect").value || "R_100",
                );
            } catch (e) {
                showStatus(`‚ùå Auth Failed: ${e.message}`, "error");
            }
        }

        // 3. Bot Control
        function startBot() {
            if (!isAuthorized) return;

            // Check Day and Update LotNo
            checkNewDay();
            loadAppData();

            // SAFETY: Load Risk Config
            riskConfig.maxDailyLoss =
                parseFloat(document.getElementById("maxDailyLoss").value) ||
                50;
            riskConfig.maxSessionLoss =
                parseFloat(
                    document.getElementById("maxSessionLoss").value,
                ) || 20;
            riskConfig.maxConsecLoss =
                parseInt(document.getElementById("maxConsecLoss").value) ||
                5;
            riskConfig.reducePct =
                parseFloat(document.getElementById("reducePct").value) ||
                30;
            riskConfig.minStake =
                parseFloat(document.getElementById("minStake").value) || 1;

            // ‚ö†Ô∏è DAILY LOSS LIMIT CHECK DISABLED - ‡πÄ‡∏ó‡∏£‡∏î‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢
            // (‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Daily Loss Limit)

            appData.currentLotNo++;
            saveAppData();

            // Initialize Session Data
            totalLoops = parseInt(
                document.getElementById("loopCount").value,
            );
            delaySeconds = parseInt(
                document.getElementById("loopDelay").value,
            );
            currentLoop = 0;
            isBotRunning = true;
            sessionStats = { wins: 0, losses: 0, pnl: 0 };
            currentDetailTrade = [];
            consecutiveLosses = 0;

            // SAFETY: Set Initial Stake
            baseStake =
                parseFloat(document.getElementById("stakeAmount").value) ||
                10;
            currentStake = baseStake;

            // Initialize HeadTrade
            currentHeadTrade = {
                CurrentLotNo: appData.currentLotNo,
                TotalTrade: appData.currentLotNo, // "‡∏à‡∏≥‡∏ô‡∏ß‡∏ô Lost ‡∏ó‡∏µ‡πà‡πÄ‡∏ó‡∏£‡∏î‡πÉ‡∏ô‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ" (Lots traded today)
                StartTrade: new Date().toLocaleString("th-TH"),
                EndTrade: null,
                BalanceOfDay: appData.dailyBalance,
                LastTrade: null,
                LastProfit: 0,
            };

            // Reset UI
            document.querySelector("#logTable tbody").innerHTML = "";
            updateStatsUI();
            updateHeadTradeUI();

            document.getElementById("mainTabs").style.display = "flex";
            document.getElementById("tab-session").style.display = "block";

            // Buttons
            document.getElementById("btnStart").style.display = "none";
            document.getElementById("btnStop").style.display = "block";

            // Show Dashboard
            document.getElementById("tradeDashboard").style.display =
                "grid";

            // Save Initial Start
            saveSessionToLocalStorage();

            showStatus(
                `üöÄ Bot Started. Lot No: ${appData.currentLotNo}. Target: ${totalLoops} rounds.`,
                "info",
            );

            // Start Loop
            processNextTrade();
        }

        function clearHistory() {
            if (
                !confirm(
                    "Are you sure you want to clear ALL trade history for today? This cannot be undone.",
                )
            )
                return;

            // Clear Specific LocalStorage Items
            localStorage.removeItem("derivBot_lotNo");
            localStorage.removeItem("derivBot_dailyBalance");
            localStorage.removeItem("derivBot_totalTrades");

            // Clear Session Keys (Clean everything starting with derivBot_session_)
            Object.keys(localStorage).forEach((key) => {
                if (key.startsWith("derivBot_session_")) {
                    localStorage.removeItem(key);
                }
            });

            // Reset App Data
            appData = {
                currentLotNo: 0,
                dailyBalance: 0,
                totalTradesToday: 0,
            };
            currentHeadTrade = {};
            currentDetailTrade = [];
            sessionStats = { wins: 0, losses: 0, pnl: 0 };

            // Update UI
            document.querySelector("#logTable tbody").innerHTML = "";
            document.getElementById("detailTradeJson").innerHTML = "";
            document.getElementById("headTradeDisplay").innerHTML =
                "<p>History Cleared. Waiting for new trade...</p>";
            updateStatsUI();

            showStatus("üóëÔ∏è History Cleared.", "success");
        }

        function stopBot() {
            isBotRunning = false;
            showStatus("‚èπ Bot Stopped by user.", "status-info");
            document.getElementById("btnStart").style.display = "block";
            document.getElementById("btnStop").style.display = "none";

            // Finalize HeadTrade EndTime if not already set
            if (currentHeadTrade) {
                currentHeadTrade.EndTrade = new Date().toLocaleString(
                    "th-TH",
                );
                saveSessionToLocalStorage();
                updateHeadTradeUI();
            }
        }

        // 4. Trade Loop Processor
        async function processNextTrade() {
            if (!isBotRunning || currentLoop >= totalLoops) {
                finishBot();
                return;
            }

            currentLoop++;
            showStatus(
                `üîÑ Processing Round ${currentLoop} / ${totalLoops} (Lot ${appData.currentLotNo})...`,
                "info",
            );

            try {
                // Clear barriers before new trade
                updateBarriers(null, null);

                const result = await executeSingleTrade();
                logTradeResult(result);
            } catch (e) {
                console.error("Trade Error", e);
                logTradeResult({
                    result: "ERROR",
                    profit: 0,
                    time: new Date(),
                    asset: "ERR",
                    growth: 0,
                    stake: 0,
                    takeProfit: 0,
                });
            }

            if (isBotRunning && currentLoop < totalLoops) {
                let d = delaySeconds;
                const interval = setInterval(() => {
                    if (!isBotRunning) {
                        clearInterval(interval);
                        return;
                    }
                    showStatus(
                        `‚è≥ Waiting ${d}s for next round...`,
                        "status-info",
                    );
                    d--;
                    if (d < 0) {
                        clearInterval(interval);
                        processNextTrade();
                    }
                }, 1000);
            } else if (currentLoop >= totalLoops) {
                finishBot();
            }
        }

        function finishBot() {
            isBotRunning = false;
            showStatus(
                `üèÅ Bot Finished. Total Rounds: ${currentLoop}`,
                "success",
            );

            const audio = document.getElementById("applauseSound");
            if (audio) {
                audio
                    .play()
                    .catch((e) => console.log("Audio play failed:", e));
            }

            document.getElementById("btnStart").style.display = "block";
            document.getElementById("btnStop").style.display = "none";

            // Mark End Time
            currentHeadTrade.EndTrade = new Date().toLocaleString("th-TH");
            saveSessionToLocalStorage();
            updateHeadTradeUI();
        }

        // 5. Single Trade Execution
        function executeSingleTrade() {
            return new Promise(async (resolve, reject) => {
                const symbol =
                    document.getElementById("assetSelect").value || "R_100";
                const growthRate = parseFloat(
                    document.getElementById("growthRate").value || 0.03,
                );

                // SAFETY: Use Dynamic Position Sizing
                const stake = currentStake;

                const targetProfit = parseFloat(
                    document.getElementById("takeProfit").value,
                );

                // SAFETY: Log stake being used
                console.log(
                    `üí∞ Using Stake: $${stake.toFixed(2)} (Base: $${baseStake}, Consec Loss: ${consecutiveLosses})`,
                );

                // Subscription ID for this trade's monitor
                let tradeSubId = null;
                let sellReason = "UNKNOWN";

                try {
                    // Safety Delay before starting a new trade to ensure previous one is cleared
                    // Increased to 3s because user still sees OpenPositionLimitExceeded
                    await new Promise((r) => setTimeout(r, 3000));

                    const propReq = {
                        proposal: 1,
                        amount: stake,
                        basis: "stake",
                        contract_type: "ACCU",
                        currency: "USD",
                        symbol: symbol,
                        growth_rate: growthRate,
                    };

                    const propResp = await api.sendAndWait(propReq);
                    if (propResp.error)
                        throw new Error(propResp.error.message);

                    // Draw Barriers
                    if (propResp.proposal) {
                        const p = propResp.proposal;
                        console.log("üìÑ Proposal Received:", p);

                        // Logic:
                        // Accu typically has high_barrier and low_barrier inside contract_details
                        let high = p.high_barrier;
                        let low = p.low_barrier;

                        if (p.contract_details) {
                            if (!high)
                                high = p.contract_details.high_barrier;
                            if (!low) low = p.contract_details.low_barrier;
                            // Fallback for barrier logic if needed
                            if (!high && p.contract_details.barrier)
                                high = p.contract_details.barrier;
                        }

                        // Fallback if high_barrier is missing but barrier exists (unlikely for Accu but possible)
                        if (!high && p.barrier) high = p.barrier;

                        const entrySpot = p.spot ? parseFloat(p.spot) : null;
                        console.log(
                            `üõ°Ô∏è Barriers Detect: High=${high}, Low=${low}, Entry=${entrySpot}`,
                        );
                        updateBarriers(high, low, null, entrySpot);
                    }

                    // Calculate Initial Gap for Danger Visualization
                    let initialGap = null;
                    const pProp = propResp.proposal;

                    // Try barrier_spot_distance first
                    if (
                        pProp &&
                        pProp.contract_details &&
                        pProp.contract_details.barrier_spot_distance
                    ) {
                        initialGap = parseFloat(
                            pProp.contract_details.barrier_spot_distance,
                        );
                    }

                    // Fallback: Manual Calculation
                    if (!initialGap && pProp) {
                        let high = pProp.high_barrier;
                        let low = pProp.low_barrier;
                        const s = parseFloat(pProp.spot);

                        if (pProp.contract_details) {
                            if (!high) high = pProp.contract_details.high_barrier;
                            if (!low) low = pProp.contract_details.low_barrier;
                        }

                        if (high && low && !isNaN(s)) {
                            const gapUp = parseFloat(high) - s;
                            const gapDown = s - parseFloat(low);
                            initialGap = Math.min(gapUp, gapDown);
                            console.log(`üìè Calculated Initial Gap Manually: ${initialGap.toFixed(4)} (H:${high} L:${low} S:${s})`);
                        } else if (pProp.barrier && !isNaN(s)) {
                            initialGap = Math.abs(parseFloat(pProp.barrier) - s);
                        }
                    }

                    // Draw Entry Price Line
                    if (propResp.proposal) {
                        const spot = parseFloat(propResp.proposal.spot);
                        updateEntryLine(spot);
                    }

                    const proposalId = propResp.proposal.id;
                    const buyResp = await api.sendAndWait({
                        buy: proposalId,
                        price: propResp.proposal.ask_price,
                    });
                    if (buyResp.error)
                        throw new Error(buyResp.error.message);

                    const contractId = buyResp.buy.contract_id;

                    // Update barriers with contract ID
                    if (propResp.proposal) {
                        const p = propResp.proposal;
                        let high = p.high_barrier;
                        let low = p.low_barrier;
                        if (p.contract_details) {
                            if (!high)
                                high = p.contract_details.high_barrier;
                            if (!low) low = p.contract_details.low_barrier;
                        }
                        const entrySpot = parseFloat(p.spot);
                        updateBarriers(high, low, contractId, entrySpot);
                    }

                    api.send({
                        proposal_open_contract: 1,
                        contract_id: contractId,
                        subscribe: 1,
                    });

                    let prevMinGap = null;

                    const monitorHandler = (data) => {
                        const contract = data.proposal_open_contract;
                        if (
                            !contract ||
                            contract.contract_id !== contractId
                        )
                            return;

                        const profit = parseFloat(contract.profit);
                        const currentSpot = parseFloat(
                            contract.current_spot,
                        );
                        const highBarrier = parseFloat(
                            contract.high_barrier,
                        );
                        const lowBarrier = parseFloat(contract.low_barrier);

                        // Update current trade profit for OHLC display
                        currentTradeProfit = profit;

                        // Safety & Panic Logic (The Danger Formula)
                        if (
                            !contract.is_sold &&
                            !isNaN(currentSpot) &&
                            !isNaN(highBarrier) &&
                            !isNaN(lowBarrier)
                        ) {
                            const gapUp = highBarrier - currentSpot;
                            const gapDown = currentSpot - lowBarrier;

                            // SafetyGap: Distance to nearest barrier
                            const minGap = Math.min(gapUp, gapDown);

                            // Velocity: How fast is the gap closing? (Positive = Danger)
                            let gapVelocity = 0;
                            if (prevMinGap !== null) {
                                gapVelocity = prevMinGap - minGap;
                            }

                            // Thresholds (Dynamic & Aggressive)
                            // Strategy: Protect the downside aggressively.

                            // Get user config
                            // Get user config
                            const panicInput =
                                document.getElementById("panicPct");
                            const velocityInput =
                                document.getElementById("velocityPct");

                            const userPanicPct = panicInput
                                ? parseFloat(panicInput.value) / 100
                                : 0.4;
                            const userVelPct = velocityInput
                                ? parseFloat(velocityInput.value) / 100
                                : 0.3;

                            let panicT = 0.1; // Fallback
                            let velocityT = 0.2; // Fallback

                            if (initialGap) {
                                panicT = initialGap * userPanicPct;
                                velocityT = initialGap * userVelPct;

                                // SAFETY: ‡∏ñ‡πâ‡∏≤‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô‡∏ï‡∏¥‡∏î‡∏Å‡∏±‡∏ô ‡πÉ‡∏´‡πâ‡∏Ç‡∏≤‡∏¢‡πÄ‡∏£‡πá‡∏ß‡∏Ç‡∏∂‡πâ‡∏ô (‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢)
                                if (consecutiveLosses >= 2) {
                                    const safetyMultiplier =
                                        1 + consecutiveLosses * 0.1; // ‡πÄ‡∏û‡∏¥‡πà‡∏° 10% ‡∏ï‡πà‡∏≠‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà‡πÅ‡∏û‡πâ
                                    panicT = panicT * safetyMultiplier;
                                    velocityT =
                                        velocityT *
                                        (safetyMultiplier * 0.8);
                                    console.log(
                                        `üõ°Ô∏è SAFETY MODE: Panic threshold increased by ${(safetyMultiplier * 100).toFixed(0)}% due to ${consecutiveLosses} consecutive losses`,
                                    );
                                }
                            }

                            // üö® CRITICAL: CHECK PANIC SELL FIRST to minimize latency
                            // "‡∏Ç‡∏≤‡∏¢‡∏´‡∏°‡∏π‡∏î‡∏µ‡∏Å‡∏ß‡πà‡∏≤‡πÄ‡∏™‡∏µ‡∏¢‡πÄ‡∏á‡∏¥‡∏ô" (Better sell early than lose)
                            let isPanic = false;
                            if (
                                minGap < panicT ||
                                gapVelocity > velocityT
                            ) {
                                console.warn(
                                    `üö® AGGRESSIVE DEFENSE TRIGGERED! Selling immediately.`,
                                );
                                api.send({ sell: contractId, price: 0 });
                                isPanic = true;
                            }

                            // Visualize danger in console periodically or if critical
                            if (
                                minGap < panicT * 1.5 ||
                                gapVelocity > velocityT * 0.5
                            ) {
                                console.log(
                                    `‚ö†Ô∏è Danger Monitor: Gap=${minGap.toFixed(4)} (Limit: ${panicT.toFixed(4)}) | Vel=${gapVelocity.toFixed(4)}`,
                                );
                            }

                            // Update Dashboard
                            updateTradeDashboard({
                                spot: currentSpot,
                                gap: minGap,
                                initialGap: initialGap,
                                velocity: gapVelocity,
                                profit: profit,
                                panicT: panicT,
                                velocityT: velocityT,
                                isPanic: isPanic,
                            });

                            prevMinGap = minGap;

                            // Visual: Update Background Color
                            if (initialGap) {
                                updateChartDangerLevel(minGap, initialGap);
                            }
                        }

                        if (!contract.is_sold && profit >= targetProfit) {
                            api.send({ sell: contractId, price: 0 });
                            if (sellReason === "UNKNOWN") sellReason = "TAKE_PROFIT";
                        }

                        if (contract.is_sold) {
                            if (data.subscription)
                                api.send({ forget: data.subscription.id });

                            // Reset Chart Background & Dashboard
                            tickChart.applyOptions({
                                layout: {
                                    background: {
                                        type: "solid",
                                        color: "#1e1e1e",
                                    },
                                },
                            });
                            if (candleChart)
                                candleChart.applyOptions({
                                    layout: {
                                        background: {
                                            type: "solid",
                                            color: "#1e3e1e",
                                        },
                                    },
                                });

                            const finalProfit = parseFloat(
                                contract.profit,
                            );

                            // Finalize sell reason if forgot
                            if (finalProfit < 0) sellReason = "HIT_BARRIER";
                            else if (sellReason === "UNKNOWN" && finalProfit > 0) sellReason = "MANUAL_OR_EXPIRE";
                            else if (sellReason === "UNKNOWN" && finalProfit === 0) sellReason = "BREAK_EVEN";

                            // Track loss and add marker
                            if (finalProfit < 0) {
                                const hitHigh = currentSpot >= highBarrier;
                                const hitLow = currentSpot <= lowBarrier;

                                const lossData = {
                                    time: contract.sell_time || Math.floor(Date.now() / 1000),
                                    spot: currentSpot,
                                    hitBarrier: hitHigh ? "HIGH" : (hitLow ? "LOW" : "UNKNOWN"),
                                    barrierPrice: hitHigh ? highBarrier : lowBarrier,
                                    profit: finalProfit,
                                    timestamp: new Date().toLocaleString('th-TH'),
                                };

                                lossTradesData.push(lossData);

                                // Add marker to candle chart
                                if (candleSeries) {
                                    const markers = lossTradesData.map(loss => ({
                                        time: loss.time,
                                        position: loss.hitBarrier === "HIGH" ? 'aboveBar' : 'belowBar',
                                        color: '#ff0000',
                                        shape: 'circle',
                                        text: 'üí• LOSS',
                                    }));
                                    candleSeries.setMarkers(markers);
                                }

                                console.log(`üí• LOSS DETECTED: Hit ${lossData.hitBarrier} barrier at ${lossData.barrierPrice}`);
                                updateTickDataDisplay();
                            }

                            // Reset trade profit
                            currentTradeProfit = 0;
                            currentTradeBarriers.contractId = null;

                            // Determine result Status
                            let resultStatus = finalProfit >= 0 ? "WIN" : "LOSS";
                            if (finalProfit === 0) {
                                if (sellReason.includes("PANIC")) resultStatus = "PROTECTED";
                                else resultStatus = "BREAK-EVEN";
                            }

                            resolve({
                                result: resultStatus,
                                profit: finalProfit,
                                time: new Date(),
                                asset: symbol,
                                growth: growthRate,
                                stake: stake,
                                takeProfit: targetProfit,
                                reason: sellReason
                            });
                        }
                    };

                    api.on("proposal_open_contract", monitorHandler);
                } catch (e) {
                    reject(e);
                }
            });
        }

        // 6. Logging & Data Management
        function logTradeResult(result) {
            // SAFETY: Update Risk Tracking
            const wins = ["WIN", "PROTECTED", "BREAK-EVEN"];

            if (wins.includes(result.result)) {
                consecutiveLosses = 0;
                currentStake = baseStake; // Reset to base on win
            } else if (result.result === "LOSS") {
                consecutiveLosses++;

                // SAFETY: Reduce stake on loss
                if (riskConfig.reducePct > 0) {
                    currentStake =
                        currentStake * (1 - riskConfig.reducePct / 100);
                    if (currentStake < riskConfig.minStake) {
                        currentStake = riskConfig.minStake;
                    }
                    console.log(
                        `‚¨áÔ∏è Stake Reduced: $${currentStake.toFixed(2)} (Consec Loss: ${consecutiveLosses})`,
                    );
                }
            }

            // SAFETY: Check Session Loss Limit
            if (Math.abs(sessionStats.pnl) >= riskConfig.maxSessionLoss) {
                console.warn(
                    `üõë SESSION LOSS LIMIT! Loss: $${Math.abs(sessionStats.pnl).toFixed(2)}`,
                );
                stopBot();
                showStatus(
                    `üõë SESSION STOPPED: Loss Limit Reached ($${Math.abs(sessionStats.pnl).toFixed(2)} / $${riskConfig.maxSessionLoss})`,
                    "error",
                );
                return;
            }

            // SAFETY: Check Consecutive Loss Limit
            if (consecutiveLosses >= riskConfig.maxConsecLoss) {
                console.warn(
                    `üõë MAX CONSECUTIVE LOSSES! Count: ${consecutiveLosses}`,
                );
                stopBot();
                showStatus(
                    `üõë SESSION STOPPED: ${consecutiveLosses} Consecutive Losses (Limit: ${riskConfig.maxConsecLoss})`,
                    "error",
                );
                return;
            }

            // SAFETY: Update Daily P&L
            appData.dailyBalance += result.profit;
            const DAILY_PNL = appData.dailyBalance; // unused var removed
            saveAppData();

            // ‚ö†Ô∏è DAILY LOSS LIMIT CHECK DISABLED - ‡πÄ‡∏ó‡∏£‡∏î‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢
            // (‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Daily Loss Limit - bot ‡∏à‡∏∞‡πÄ‡∏ó‡∏£‡∏î‡∏ï‡πà‡∏≠‡πÑ‡∏õ‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡∏´‡∏¢‡∏∏‡∏î)

            // Update Session Stats
            sessionStats.pnl += result.profit;
            if (wins.includes(result.result)) sessionStats.wins++;
            if (result.result === "LOSS") sessionStats.losses++;

            // Update Global App Data
            appData.dailyBalance += result.profit;
            appData.totalTradesToday++;
            saveAppData();

            // Construct DetailTrade Object (Feature 5)
            const tradeRecord = {
                LotNo: appData.currentLotNo,
                TradeNo: appData.totalTradesToday,
                asset: result.asset,
                stake: result.stake,
                GrowthRate: result.growth,
                TakeProfit: result.takeProfit,
                timeTrade: result.time.toLocaleString("th-TH"),
                result: result.result,
                profit: result.profit,
                balanceOnThisLot: sessionStats.pnl,
                reason: result.reason
            };
            currentDetailTrade.push(tradeRecord);

            // Update HeadTrade Object (Feature 4)
            currentHeadTrade.TotalTrade = appData.currentLotNo;
            currentHeadTrade.EndTrade = new Date().toLocaleString("th-TH");
            currentHeadTrade.BalanceOfDay = parseFloat(
                appData.dailyBalance.toFixed(2),
            );
            currentHeadTrade.LastTrade =
                result.time.toLocaleString("th-TH");
            currentHeadTrade.LastProfit = result.profit;

            // Save & UI
            saveSessionToLocalStorage();
            updateStatsUI();
            updateHeadTradeUI();
            appendLogTable(tradeRecord);
        }

        function saveSessionToLocalStorage() {
            // Feature 3: LocalStorage
            const sessionKey = `derivBot_session_${new Date().toISOString().slice(0, 10)}_${appData.currentLotNo}`;
            const dataToSave = {
                HeadTrade: currentHeadTrade,
                DetailTrade: currentDetailTrade,
            };
            localStorage.setItem(sessionKey, JSON.stringify(dataToSave));
        }

        // UI Updates
        function updateStatsUI() {
            document.getElementById("sumTotal").textContent = currentLoop;
            document.getElementById("sumWin").textContent =
                sessionStats.wins;
            document.getElementById("sumLoss").textContent =
                sessionStats.losses;
            const pnlEl = document.getElementById("sumPnl");
            pnlEl.textContent = `${sessionStats.pnl > 0 ? "+" : ""}${sessionStats.pnl.toFixed(2)} USD`;
            pnlEl.style.color =
                sessionStats.pnl >= 0 ? "#4caf50" : "#f44336";
        }

        function appendLogTable(record) {
            const tbody = document.querySelector("#logTable tbody");
            const tr = document.createElement("tr");

            let color = "#f44336"; // Red
            if (record.profit > 0) color = "#4caf50"; // Green
            else if (record.profit === 0) color = "#ff9800"; // Orange

            // Add reason to result text if available
            let resultText = record.result;
            if (record.reason && record.reason !== "UNKNOWN" && record.profit === 0) {
                resultText += ` <small>(${record.reason})</small>`;
            }

            tr.innerHTML = `
                            <td>${record.TradeNo}</td>
                            <td>${record.timeTrade.split(" ")[1]}</td>
                            <td>${record.asset}</td>
                            <td style="color:${color}; font-weight:bold;">${resultText}</td>
                            <td style="color:${color};">${record.profit > 0 ? "+" : ""}${record.profit.toFixed(2)}</td>
                            <td>${Number(record.balanceOnThisLot).toFixed(2)}</td>
                        `;
            tbody.prepend(tr);
        }

        function updateHeadTradeUI() {
            const container = document.getElementById("headTradeDisplay");
            container.innerHTML = `
                            <table style="text-align:left; max-width: 400px; margin: auto;">
                                <tr><th>Key</th><th>Value</th></tr>
                                <tr><td>CurrentLotNo</td><td>${currentHeadTrade.CurrentLotNo}</td></tr>
                                <tr><td>TotalTrade (Lots)</td><td>${currentHeadTrade.TotalTrade}</td></tr>
                                <tr><td>StartTrade</td><td>${currentHeadTrade.StartTrade}</td></tr>
                                <tr><td>EndTrade</td><td>${currentHeadTrade.EndTrade || "-"}</td></tr>
                                <tr><td>BalanceOfDay</td><td style="color:${currentHeadTrade.BalanceOfDay >= 0 ? "lime" : "red"}">${currentHeadTrade.BalanceOfDay}</td></tr>
                                <tr><td>LastTrade</td><td>${currentHeadTrade.LastTrade || "-"}</td></tr>
                                <tr><td>LastProfit</td><td style="color:${currentHeadTrade.LastProfit >= 0 ? "lime" : "red"}">${currentHeadTrade.LastProfit}</td></tr>
                            </table>
                        `;

            // Pretty Print JSON
            document.getElementById("detailTradeJson").innerHTML =
                syntaxHighlight(currentDetailTrade);
        }

        // Tab Switching
        function switchTab(tabName) {
            // Update Buttons
            document
                .querySelectorAll(".tab-btn")
                .forEach((b) => b.classList.remove("active"));
            // Update Content
            document
                .querySelectorAll(".tab-content")
                .forEach((c) => (c.style.display = "none"));

            if (tabName === "session") {
                document
                    .querySelector(
                        "button[onclick=\"switchTab('session')\"]",
                    )
                    .classList.add("active");
                document.getElementById("tab-session").style.display =
                    "block";
            } else {
                document
                    .querySelector(
                        "button[onclick=\"switchTab('headTrade')\"]",
                    )
                    .classList.add("active");
                document.getElementById("tab-headTrade").style.display =
                    "block";
            }
        }

        // JSON Beautifier
        function syntaxHighlight(json) {
            if (typeof json != "string")
                json = JSON.stringify(json, undefined, 2);
            json = json
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;");
            return json.replace(
                /("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g,
                function (match) {
                    var cls = "json-number";
                    if (/^"/.test(match)) {
                        if (/:$/.test(match)) {
                            cls = "json-key";
                        } else {
                            cls = "json-string";
                        }
                    } else if (/true|false/.test(match)) {
                        cls = "json-boolean";
                    } else if (/null/.test(match)) {
                        cls = "json-null";
                    }
                    return '<span class="' + cls + '">' + match + "</span>";
                },
            );
        }

        // Select Helpers
        const growthOptions = document.querySelectorAll(".growth-option");
        const growthInput = document.getElementById("growthRate");
        growthOptions.forEach((opt) => {
            opt.addEventListener("click", () => {
                growthOptions.forEach((o) =>
                    o.classList.remove("selected"),
                );
                opt.classList.add("selected");
                growthInput.value = opt.getAttribute("data-value");
            });
        });

        function showStatus(msg, type) {
            const el = document.getElementById("status");
            el.innerHTML = msg;
            el.className =
                type === "error"
                    ? "status-error"
                    : type === "success"
                        ? "status-success"
                        : "status-info";
            el.style.display = "block";
        }

        // --- Chart Functions ---
        function initChart() {
            // 1. Tick Chart
            const tickContainer =
                document.getElementById("tickChartContainer");
            tickChart = LightweightCharts.createChart(tickContainer, {
                width: tickContainer.offsetWidth,
                height: window.innerHeight - 200,
                layout: {
                    background: { type: "solid", color: "#1e1e1e" },
                    textColor: "#d1d4f9",
                },
                grid: {
                    vertLines: { color: "rgba(42, 46, 57, 0.5)" },
                    horzLines: { color: "rgba(42, 46, 57, 0.5)" },
                },
                timeScale: {
                    timeVisible: true,
                    secondsVisible: true,
                    barSpacing: 8,
                    rightOffset: 12,
                    minBarSpacing: 3,
                },
                rightPriceScale: {
                    autoScale: true,
                    scaleMargins: {
                        top: 0.1,
                        bottom: 0.1,
                    },
                },
            });

            lineSeries = tickChart.addLineSeries({
                color: "#4ec9b0",
                lineWidth: 2,
            });

            indicatorSeries = tickChart.addLineSeries({
                color: "#ff9800", // Orange
                lineWidth: 1,
                lineStyle: LightweightCharts.LineStyle.Solid,
            });

            // 2. Candle Chart
            const candleContainer = document.getElementById(
                "candleChartContainer",
            );
            candleChart = LightweightCharts.createChart(candleContainer, {
                width: candleContainer.offsetWidth,
                height: window.innerHeight - 200,
                layout: {
                    background: { type: "solid", color: "#1e1e1e" },
                    textColor: "#d1d4f9",
                },
                grid: {
                    vertLines: { color: "rgba(42, 46, 57, 0.5)" },
                    horzLines: { color: "rgba(42, 46, 57, 0.5)" },
                },
                timeScale: {
                    timeVisible: true,
                    secondsVisible: true,
                    barSpacing: 50,
                    rightOffset: 12,
                    minBarSpacing: 15,
                },
                rightPriceScale: {
                    autoScale: true,
                    scaleMargins: {
                        top: 0.1,
                        bottom: 0.1,
                    },
                },
            });

            candleSeries = candleChart.addCandlestickSeries({
                upColor: "#26a69a",
                downColor: "#ef5350",
                borderVisible: true,
                borderUpColor: "#26a69a",
                borderDownColor: "#ef5350",
                wickUpColor: "#26a69a",
                wickDownColor: "#ef5350",
                wickVisible: true,
            });

            // Resize Observer
            const resizeObserver = new ResizeObserver((entries) => {
                for (const entry of entries) {
                    if (
                        entry.target.id === "tickChartContainer" &&
                        tickChart
                    ) {
                        tickChart.applyOptions({
                            width: entry.contentRect.width,
                        });
                    } else if (
                        entry.target.id === "candleChartContainer" &&
                        candleChart
                    ) {
                        // Ensure width is valid before applying
                        if (entry.contentRect.width > 0) {
                            candleChart.applyOptions({
                                width: entry.contentRect.width,
                            });
                        }
                    }
                }
            });

            // Observe both containers explicitly
            const tickEl = document.getElementById("tickChartContainer");
            const candleEl = document.getElementById(
                "candleChartContainer",
            );
            if (tickEl) resizeObserver.observe(tickEl);
            if (candleEl) resizeObserver.observe(candleEl);
        }

        function switchChartTab(tab) {
            const tickC = document.getElementById("tickChartContainer");
            const candC = document.getElementById("candleChartContainer");
            const tabs = document.querySelectorAll(".tabs button");

            if (tab === "tick") {
                tickC.style.display = "block";
                candC.style.display = "none";
                tabs[0].classList.add("active");
                tabs[1].classList.remove("active");
                if (tickChart) tickChart.timeScale().fitContent();
            } else {
                tickC.style.display = "none";
                candC.style.display = "block";
                tabs[0].classList.remove("active");
                tabs[1].classList.add("active");
                if (candleChart) candleChart.timeScale().fitContent();
            }
        }

        function updateBarriers(high, low, contractId) {
            console.log(`üìâ Drawing Barriers: High=${high}, Low=${low}`);

            // Store current trade barriers
            currentTradeBarriers = {
                high: parseFloat(high),
                low: parseFloat(low),
                contractId: contractId,
            };

            // Update Line Chart Barriers
            if (lineSeries) {
                // Remove existing
                if (highBarrierLine) {
                    lineSeries.removePriceLine(highBarrierLine);
                    highBarrierLine = null;
                }
                if (lowBarrierLine) {
                    lineSeries.removePriceLine(lowBarrierLine);
                    lowBarrierLine = null;
                }

                // Add new
                if (high) {
                    highBarrierLine = lineSeries.createPriceLine({
                        price: parseFloat(high),
                        color: "#ef5350",
                        lineWidth: 2,
                        lineStyle: LightweightCharts.LineStyle.Dashed,
                        axisLabelVisible: true,
                        title: "High Barrier",
                    });
                }
                if (low) {
                    lowBarrierLine = lineSeries.createPriceLine({
                        price: parseFloat(low),
                        color: "#66bb6a",
                        lineWidth: 2,
                        lineStyle: LightweightCharts.LineStyle.Dashed,
                        axisLabelVisible: true,
                        title: "Low Barrier",
                    });
                }
            }

            // Update Candle Chart Barriers
            if (candleSeries) {
                // Remove existing
                if (candleHighBarrierLine) {
                    candleSeries.removePriceLine(candleHighBarrierLine);
                    candleHighBarrierLine = null;
                }
                if (candleLowBarrierLine) {
                    candleSeries.removePriceLine(candleLowBarrierLine);
                    candleLowBarrierLine = null;
                }

                // Add new
                if (high) {
                    candleHighBarrierLine = candleSeries.createPriceLine({
                        price: parseFloat(high),
                        color: "#ef5350",
                        lineWidth: 2,
                        lineStyle: LightweightCharts.LineStyle.Dashed,
                        axisLabelVisible: true,
                        title: "High Barrier",
                    });
                }
                if (low) {
                    candleLowBarrierLine = candleSeries.createPriceLine({
                        price: parseFloat(low),
                        color: "#66bb6a",
                        lineWidth: 2,
                        lineStyle: LightweightCharts.LineStyle.Dashed,
                        axisLabelVisible: true,
                        title: "Low Barrier",
                    });
                }
            }
        }

        function updateEntryLine(price) {
            if (!lineSeries) return;
            if (entryPriceLine) {
                lineSeries.removePriceLine(entryPriceLine);
                entryPriceLine = null;
            }
            if (price !== null) {
                entryPriceLine = lineSeries.createPriceLine({
                    price: parseFloat(price),
                    color: "#888888", // Grey
                    lineWidth: 1,
                    lineStyle: LightweightCharts.LineStyle.Dotted,
                    axisLabelVisible: true,
                    title: "Entry",
                });
            }
        }

        function calculateWMA(data, period) {
            if (data.length < period) return null;
            let sum = 0;
            let weightSum = 0;
            for (let i = 0; i < period; i++) {
                const weight = period - i;
                sum += data[data.length - 1 - i].value * weight;
                weightSum += weight;
            }
            return sum / weightSum;
        }

        function calculateHMA_Value(data, period) {
            // HMA = WMA(2*WMA(n/2) - WMA(n)), sqrt(n))
            if (data.length < period) return null;

            // We need historical WMAs to calculate the final WMA
            // This is expensive to do on every tick for the whole chart,
            // but for a single point update it's okay.
            // To draw the whole line, we need to iterate.

            // Simplified: Just return null if insufficient data.
            // We need a series of "2*WMA(n/2) - WMA(n)" values to compute the outer WMA.
            // Let's implement a vector-based WMA for the visible range.
            return null;
        }

        // Vectorized Indicator Calculation for Initial File Load
        function calculateIndicatorsVector(data) {
            const type = document.getElementById("indicatorType").value;
            const period = parseInt(
                document.getElementById("indicatorPeriod").value,
            );
            const results = [];

            if (type === "EMA") {
                const k = 2 / (period + 1);
                let ema = data[0].value;
                for (let i = 0; i < data.length; i++) {
                    if (i > 0) ema = (data[i].value - ema) * k + ema;
                    results.push({ time: data[i].time, value: ema });
                }
            } else {
                // HMA Implementation
                // Needs specialized loop
                // WMA function on array
                const getWMA = (arr, p, idx) => {
                    if (idx < p - 1) return null;
                    let sum = 0;
                    let wSum = 0;
                    for (let j = 0; j < p; j++) {
                        let weight = p - j;
                        sum += arr[idx - j].value * weight;
                        wSum += weight;
                    }
                    return sum / wSum;
                };

                const halfP = Math.floor(period / 2);
                const sqrtP = Math.floor(Math.sqrt(period));
                const rawHMAs = []; // Stores 2*WMA(n/2) - WMA(n)

                for (let i = 0; i < data.length; i++) {
                    const wmaFull = getWMA(data, period, i);
                    const wmaHalf = getWMA(data, halfP, i);

                    if (wmaFull !== null && wmaHalf !== null) {
                        rawHMAs.push({ value: 2 * wmaHalf - wmaFull }); // No time needed yet, just index aligned? No, index shifts.
                        // Actually, alignment is tricky.
                        // rawHMAs[0] corresponds to index `period-1` of data.
                    } else {
                        rawHMAs.push(null);
                    }
                }

                // Final WMA on rawHMAs
                for (let i = 0; i < data.length; i++) {
                    if (i < period + sqrtP + 10) {
                        // Safety padding
                        // results.push({ time: data[i].time, value: data[i].value }); // Don't draw garbage
                        continue;
                    }

                    // Custom WMA on the rawHMAs buffer
                    // We need previous `sqrtP` values of rawHMAs ending at `i`
                    let sum = 0,
                        wSum = 0;
                    let missing = false;
                    for (let j = 0; j < sqrtP; j++) {
                        const val = rawHMAs[i - j];
                        if (val === null || val === undefined) {
                            missing = true;
                            break;
                        }
                        const weight = sqrtP - j;
                        sum += val.value * weight;
                        wSum += weight;
                    }

                    if (!missing) {
                        results.push({
                            time: data[i].time,
                            value: sum / wSum,
                        });
                    }
                }
            }
            return results;
        }

        // Single Tick Update
        function updateIndicatorChart() {
            // Removed tickData parameter as it's not used in the current implementation
            if (!indicatorSeries || tickDataBuffer.length === 0) return;

            // Re-calculate full series?
            // For HMA it's complex to do incremental.
            // Given the chart buffer size (usually 1000 candles max for performance),
            // re-calculating the vector is usually fast enough in JS ( < 5ms).
            // Let's just re-calc the whole indicator series for simplicity and correctness.

            const indicatorData = calculateIndicatorsVector(tickDataBuffer);
            if (indicatorData.length > 0) {
                indicatorSeries.setData(indicatorData);
                // Note: setData is heavier than update().
                // But for standard tick speed (1 tick/sec), it's fine.
            }
        }

        function updateChartDangerLevel(currentGap, maxGap) {
            if (!tickChart || !currentGap || !maxGap) return;

            // Calculate Risk ratio (0 = Dead, 1 = Safe)
            const ratio = Math.max(0, Math.min(1, currentGap / maxGap));

            let color = "#1e1e1e"; // Default Dark

            if (ratio < 0.2) {
                // Critical Danger (Red Tint)
                // Interpolate strictly for critical zone
                const intensity = Math.floor((1 - ratio / 0.2) * 50);
                color = `rgba(${30 + intensity}, 30, 30, 1)`;
            } else if (ratio < 0.5) {
                // Warning (Yellow/Orange Tint)
                const intensity = Math.floor(
                    (1 - (ratio - 0.2) / 0.3) * 30,
                );
                color = `rgba(${30 + intensity}, ${30 + intensity}, 30, 1)`;
            }

            tickChart.applyOptions({
                layout: {
                    background: { type: "solid", color: color },
                },
            });
        }

        function updateTradeDashboard(data) {
            const dashSpot = document.getElementById("dashSpot");
            const dashGap = document.getElementById("dashGap");
            const dashGapPct = document.getElementById("dashGapPct");
            const dashVel = document.getElementById("dashVel");
            const dashProfit = document.getElementById("dashProfit");
            const dashStatus = document.getElementById("dashStatus");

            if (!data) {
                // Reset
                dashSpot.innerText = "--";
                dashGap.innerText = "--";
                dashGapPct.innerText = "(--%)";
                dashVel.innerText = "--";
                dashProfit.innerText = "--";
                dashStatus.innerText = "WAITING FOR TRADE...";
                dashStatus.style.background = "#333";
                dashStatus.style.color = "#aaa";
                return;
            }

            // Spot
            dashSpot.innerText = data.spot.toFixed(3);

            // Profit
            dashProfit.innerText =
                (data.profit > 0 ? "+" : "") +
                data.profit.toFixed(2) +
                " USD";
            dashProfit.style.color =
                data.profit >= 0 ? "#4caf50" : "#ef5350";

            // Gap
            const gapPct =
                data.initialGap > 0
                    ? (data.gap / data.initialGap) * 100
                    : 0;
            dashGap.innerText = data.gap.toFixed(4);
            dashGapPct.innerText = `(${gapPct.toFixed(1)}%)`;

            // Gap Colors
            if (data.gap < data.panicT)
                dashGap.style.color = "#ef5350"; // Red
            else if (data.gap < data.panicT * 1.5)
                dashGap.style.color = "#ff9800"; // Orange
            else dashGap.style.color = "#4caf50"; // Green

            // Velocity
            dashVel.innerText = data.velocity.toFixed(4);
            if (data.velocity > data.velocityT)
                dashVel.style.color = "#ef5350";
            else if (data.velocity > data.velocityT * 0.5)
                dashVel.style.color = "#ff9800";
            else dashVel.style.color = "#ccc";

            // Balance
            const dashBalance = document.getElementById("dashBalance");
            if (dashBalance) {
                const bal = typeof balance !== 'undefined' ? balance : appData.dailyBalance;
                dashBalance.innerText = (bal || 0).toFixed(2) + " USD";
            }

            // Update Lot No (Lots traded today)
            const dashLot = document.getElementById("dashLotNo");
            if (dashLot) {
                const lot = (appData && appData.totalTradesToday !== undefined) ? appData.totalTradesToday + 1 : 1;
                dashLot.innerText = lot;
                dashLot.style.color = "#fff";
            }

            const dashAction = document.getElementById("dashAction");

            // Status Logic & Thai Translation
            if (data.gap < data.panicT) {
                dashStatus.innerText = "üö® ‡∏´‡∏ô‡∏µ‡∏ï‡∏≤‡∏¢‡∏î‡πà‡∏ß‡∏ô! (GAP ‡∏≠‡∏±‡∏ô‡∏ï‡∏£‡∏≤‡∏¢‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ)";
                dashStatus.style.background = "#ef5350";
                dashStatus.style.color = "#fff";
                dashAction.innerText = "‚ö†Ô∏è ‡∏£‡∏∞‡∏ö‡∏ö‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏±‡πà‡∏á‡∏Ç‡∏≤‡∏¢‡∏ó‡∏±‡∏ô‡∏ó‡∏µ! ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏±‡∏Å‡∏©‡∏≤‡∏ó‡∏∏‡∏ô";
                dashAction.style.color = "#ffeb3b";

            } else if (data.velocity > data.velocityT) {
                dashStatus.innerText = "üö® ‡∏´‡∏ô‡∏µ‡∏ï‡∏≤‡∏¢‡∏î‡πà‡∏ß‡∏ô! (‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ß‡∏¥‡πà‡∏á‡∏•‡∏á‡πÄ‡∏£‡πá‡∏ß‡∏ú‡∏¥‡∏î‡∏õ‡∏Å‡∏ï‡∏¥)";
                dashStatus.style.background = "#ef5350";
                dashStatus.style.color = "#fff";
                dashAction.innerText = "‚ö†Ô∏è ‡∏£‡∏∞‡∏ö‡∏ö‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏±‡πà‡∏á‡∏Ç‡∏≤‡∏¢‡∏ó‡∏±‡∏ô‡∏ó‡∏µ! ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏Å‡∏£‡∏∞‡∏ä‡∏≤‡∏Å‡∏•‡∏á";
                dashAction.style.color = "#ffeb3b";

            } else if (data.gap < data.panicT * 1.5) {
                dashStatus.innerText = "‚ö†Ô∏è ‡∏£‡∏∞‡∏ß‡∏±‡∏á! GAP ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πà‡∏≥ (‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á‡∏ä‡∏ô)";
                dashStatus.style.background = "#ff9800";
                dashStatus.style.color = "#000";
                dashAction.innerText = "üëÄ ‡∏à‡∏±‡∏ö‡∏ï‡∏≤‡∏î‡∏π‡πÉ‡∏Å‡∏•‡πâ‡∏ä‡∏¥‡∏î ‡∏ñ‡πâ‡∏≤‡∏£‡πà‡∏ß‡∏á‡∏≠‡∏µ‡∏Å‡∏ô‡∏¥‡∏î‡∏à‡∏∞‡∏Ç‡∏≤‡∏¢‡∏ó‡∏¥‡πâ‡∏á";
                dashAction.style.color = "#ff9800";

            } else if (data.velocity > data.velocityT * 0.5) {
                dashStatus.innerText = "‚ö†Ô∏è ‡∏£‡∏∞‡∏ß‡∏±‡∏á! ‡∏Å‡∏£‡∏≤‡∏ü‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô";
                dashStatus.style.background = "#ff9800";
                dashStatus.style.color = "#000";
                dashAction.innerText = "üëÄ ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ß‡∏¥‡πà‡∏á‡πÄ‡∏£‡πá‡∏ß‡∏Ç‡∏∂‡πâ‡∏ô ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏ï‡∏±‡∏ß‡∏´‡∏ô‡∏µ‡∏ñ‡πâ‡∏≤‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô";
                dashAction.style.color = "#ff9800";

            } else {
                dashStatus.innerText = "‚úÖ ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢ (‡∏ñ‡∏∑‡∏≠‡∏ï‡πà‡∏≠‡πÑ‡∏î‡πâ)";
                dashStatus.style.background = "#2e7d32"; // Dark Green
                dashStatus.style.color = "#fff";
                dashAction.innerText = "‚è≥ ‡∏£‡∏≠‡∏ó‡∏≥‡∏Å‡∏≥‡πÑ‡∏£‡∏ï‡∏≤‡∏°‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢...";
                dashAction.style.color = "#81c784";
            }
        }

        // Synthetic Candle State
        let currentCandle = null;
        let CANDLE_PERIOD = 10; // 10 seconds for better visibility (now adjustable)

        // Tick Data Storage
        let tickDataStorage = [];
        const MAX_TICK_STORAGE = 10000; // Store up to 10,000 ticks
        let lossTradesData = []; // Store loss trades for markers

        function generateSyntheticCandles(ticks) {
            const candles = [];
            let candle = null;

            if (!ticks || ticks.length === 0) return [];

            for (const t of ticks) {
                const timeSlot =
                    Math.floor(t.time / CANDLE_PERIOD) * CANDLE_PERIOD;

                if (candle && candle.time === timeSlot) {
                    // Update existing
                    candle.high = Math.max(candle.high, t.value);
                    candle.low = Math.min(candle.low, t.value);
                    candle.close = t.value;
                } else {
                    // New Candle
                    if (candle) candles.push(candle);
                    candle = {
                        time: timeSlot,
                        open: t.value,
                        high: t.value,
                        low: t.value,
                        close: t.value,
                    };
                }
            }
            if (candle) candles.push(candle);
            return candles;
        }

        function updateSyntheticCandleLive(tick) {
            const timeSlot =
                Math.floor(tick.time / CANDLE_PERIOD) * CANDLE_PERIOD;

            if (currentCandle && currentCandle.time === timeSlot) {
                // Update
                currentCandle.high = Math.max(
                    currentCandle.high,
                    tick.value,
                );
                currentCandle.low = Math.min(currentCandle.low, tick.value);
                currentCandle.close = tick.value;
                candleSeries.update(currentCandle);
            } else {
                // New Candle
                currentCandle = {
                    time: timeSlot,
                    open: tick.value,
                    high: tick.value,
                    low: tick.value,
                    close: tick.value,
                };
                candleSeries.update(currentCandle);
            }
        }

        // Update Candle Interval
        function updateCandleInterval() {
            const input = document.getElementById("candleInterval");
            const newInterval = parseInt(input.value) || 10;
            CANDLE_PERIOD = newInterval;

            // Update tab label
            const tabBtn = document.getElementById("candleTabBtn");
            tabBtn.textContent = `Candles (${newInterval}s)`;

            // Regenerate candles if we have tick data
            if (tickDataBuffer.length > 0) {
                const candles = generateSyntheticCandles(tickDataBuffer);
                if (candleSeries) {
                    candleSeries.setData(candles);
                    candleChart.timeScale().fitContent();
                }
                currentCandle =
                    candles.length > 0 ? candles[candles.length - 1] : null;
            }

            log(`Candle interval updated to ${newInterval} seconds`);
        }

        // Save tick data to localStorage
        function saveTickDataToStorage(tick) {
            tickDataStorage.push({
                time: tick.time,
                value: tick.value,
                epoch: tick.epoch,
                profit: tick.profit || 0,
                timestamp: new Date(tick.time * 1000).toLocaleString("th-TH"),
            });

            // Keep only last MAX_TICK_STORAGE ticks
            if (tickDataStorage.length > MAX_TICK_STORAGE) {
                tickDataStorage = tickDataStorage.slice(-MAX_TICK_STORAGE);
            }

            // Save to localStorage
            try {
                localStorage.setItem(
                    "tickData",
                    JSON.stringify(tickDataStorage),
                );
                localStorage.setItem(
                    "lossTradesData",
                    JSON.stringify(lossTradesData),
                );
            } catch (e) {
                console.warn(
                    "Failed to save data to localStorage:",
                    e,
                );
            }

            // Update textarea
            updateTickDataDisplay();
        }

        // Load tick data from localStorage
        function loadTickDataFromStorage() {
            try {
                const stored = localStorage.getItem("tickData");
                if (stored) {
                    tickDataStorage = JSON.parse(stored);
                    updateTickDataDisplay();
                    console.log(
                        `Loaded ${tickDataStorage.length} ticks from storage`,
                    );
                }

                const storedLoss = localStorage.getItem("lossTradesData");
                if (storedLoss) {
                    lossTradesData = JSON.parse(storedLoss);
                    console.log(
                        `Loaded ${lossTradesData.length} loss trades from storage`,
                    );
                }
            } catch (e) {
                console.warn(
                    "Failed to load data from localStorage:",
                    e,
                );
                tickDataStorage = [];
                lossTradesData = [];
            }
        }

        // Update tick data display in textarea
        function updateTickDataDisplay() {
            const textarea = document.getElementById("tickDataArea");
            if (!textarea) return;

            if (tickDataStorage.length === 0) {
                textarea.value = "No data yet...";
                return;
            }

            // Show last 100 data points (most recent first)
            const recentTicks = tickDataStorage.slice(-100).reverse();
            const lines = recentTicks.map((tick) => {
                const val = parseFloat(tick.value);
                let line = `${tick.timestamp} | Close: ${isNaN(val) ? "N/A" : val.toFixed(4)}`;
                if (tick.profit !== undefined) {
                    line += ` | Profit: ${tick.profit >= 0 ? "+" : ""}${Number(tick.profit).toFixed(2)}`;
                }
                return line;
            });

            // Add Loss Trades section
            let lossSection = "";
            if (lossTradesData.length > 0) {
                lossSection = `\n\n${"=".repeat(80)}\nüí• LOSS TRADES DETECTED (${lossTradesData.length})\n${"=".repeat(80)}\n\n`;
                lossTradesData
                    .slice(-20)
                    .reverse()
                    .forEach((loss, idx) => {
                        lossSection += `${idx + 1}. ${loss.timestamp}\n`;
                        lossSection += `   Spot: ${loss.spot} | Hit ${loss.hitBarrier} Barrier @ ${loss.barrierPrice}\n`;
                        lossSection += `   Loss: $${loss.profit}\n\n`;
                    });
            }

            textarea.value =
                `üìä OHLC Subscription Active (60s Candles)\n` +
                `Total Data Points: ${tickDataStorage.length}\n` +
                `Showing Last ${recentTicks.length} Close Prices:\n` +
                `${"=".repeat(80)}\n\n` +
                lines.join("\n") +
                lossSection;

            // Auto scroll to top
            textarea.scrollTop = 0;
        }

        // Clear tick data
        function clearTickData() {
            if (confirm("Clear all stored tick data and loss markers?")) {
                tickDataStorage = [];
                lossTradesData = [];
                localStorage.removeItem("tickData");
                localStorage.removeItem("lossTradesData");

                // Clear loss markers
                if (candleSeries) {
                    candleSeries.setMarkers([]);
                }

                updateTickDataDisplay();
                console.log("‚úÖ Tick data and loss markers cleared");
            }
        }

        // Export tick data to JSON file
        function exportTickData() {
            if (tickDataStorage.length === 0) {
                alert("No tick data to export!");
                return;
            }

            const dataStr = JSON.stringify(tickDataStorage, null, 2);
            const dataBlob = new Blob([dataStr], {
                type: "application/json",
            });

            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement("a");
            link.href = url;
            link.download = `tick-data-${Date.now()}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);

            log(`Exported ${tickDataStorage.length} ticks to JSON file`);
        }

        // Import tick data from JSON file
        function importTickData() {
            const input = document.createElement("input");
            input.type = "file";
            input.accept = ".json";

            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const importedData = JSON.parse(
                            event.target.result,
                        );

                        if (!Array.isArray(importedData)) {
                            alert("Invalid data format!");
                            return;
                        }

                        // Validate data structure
                        const isValid = importedData.every(
                            (tick) =>
                                tick.time &&
                                tick.value &&
                                tick.epoch &&
                                tick.timestamp,
                        );

                        if (!isValid) {
                            alert(
                                "Invalid tick data structure! Expected: {time, value, epoch, timestamp}",
                            );
                            return;
                        }

                        // Merge or replace?
                        const action = confirm(
                            `Import ${importedData.length} ticks.\n\nClick OK to MERGE with existing data.\nClick Cancel to REPLACE existing data.`,
                        );

                        if (action) {
                            // Merge
                            tickDataStorage = [
                                ...tickDataStorage,
                                ...importedData,
                            ];
                        } else {
                            // Replace
                            tickDataStorage = importedData;
                        }

                        // Keep only last MAX_TICK_STORAGE ticks
                        if (tickDataStorage.length > MAX_TICK_STORAGE) {
                            tickDataStorage =
                                tickDataStorage.slice(-MAX_TICK_STORAGE);
                        }

                        // Save to localStorage
                        localStorage.setItem(
                            "tickData",
                            JSON.stringify(tickDataStorage),
                        );
                        updateTickDataDisplay();

                        log(
                            `Imported ${importedData.length} ticks successfully`,
                        );
                    } catch (error) {
                        alert(
                            "Failed to parse JSON file: " + error.message,
                        );
                    }
                };

                reader.readAsText(file);
            };

            input.click();
        }

        async function subscribeTicks(symbol) {
            if (!api || !isAuthorized) return;

            // Unsubscribe all
            if (tickSubscriptionId) {
                api.send({ forget: tickSubscriptionId });
                tickSubscriptionId = null;
            }

            currentSymbol = symbol;
            currentCandle = null;

            // Clear Charts
            if (lineSeries) lineSeries.setData([]);
            if (candleSeries) candleSeries.setData([]);
            if (indicatorSeries) indicatorSeries.setData([]);
            tickDataBuffer = [];

            try {
                // ‚úÖ History (OHLC Candles)
                const history = await api.sendAndWait({
                    ticks_history: symbol,
                    count: 100,
                    end: "latest",
                    style: "candles", // ‚≠ê ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô candles
                    granularity: 60, // 60 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ (1 ‡∏ô‡∏≤‡∏ó‡∏µ)
                    adjust_start_time: 1,
                    subscribe: 1, // ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏° subscribe
                });

                // ‚úÖ ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Historical Candles
                if (history.candles) {
                    const candles = history.candles.map((c) => ({
                        time: c.epoch,
                        open: c.open,
                        high: c.high,
                        low: c.low,
                        close: c.close,
                    }));

                    // ‡∏™‡∏£‡πâ‡∏≤‡∏á ticks ‡∏à‡∏≤‡∏Å candles ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Line Chart
                    const ticks = candles.map((c) => ({
                        time: c.time,
                        value: c.close,
                        epoch: c.time,
                        profit: 0, // Default profit for historical data
                    }));
                    tickDataBuffer = ticks;

                    // Save to storage
                    ticks.forEach((tick) => saveTickDataToStorage(tick));

                    // Populate Tick Chart (Line)
                    if (lineSeries) {
                        lineSeries.setData(ticks);
                        tickChart.timeScale().fitContent();
                    }

                    // Populate Candle Chart
                    if (candleSeries) {
                        candleSeries.setData(candles);
                        candleChart.timeScale().fitContent();
                    }
                    if (candles.length > 0) {
                        currentCandle = candles[candles.length - 1];
                    }
                }

                updateIndicatorChart(); // Calc indicators

                // ‚úÖ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å subscription ID
                if (history.subscription) {
                    tickSubscriptionId = history.subscription.id;
                }
            } catch (e) {
                console.error("Chart sub failed", e);
            }
        }

        // Single Tick Update
        function updateIndicatorChart() {
            if (!indicatorSeries || tickDataBuffer.length === 0) return;

            // Re-calculate full series?
            // For HMA it's complex to do incremental.
            // Given the chart buffer size (usually 1000 candles max for performance),
            // re-calculating the vector is usually fast enough in JS ( < 5ms).
            // Let's just re-calc the whole indicator series for simplicity and correctness.

            const indicatorData = calculateIndicatorsVector(tickDataBuffer);
            if (indicatorData.length > 0) {
                indicatorSeries.setData(indicatorData);
                // Note: setData is heavier than update().
                // But for standard tick speed (1 tick/sec), it's fine.
            }
        }

        function updateTradeDashboard(data) {
            const dashSpot = document.getElementById("dashSpot");
            const dashGap = document.getElementById("dashGap");
            const dashGapPct = document.getElementById("dashGapPct");
            const dashVel = document.getElementById("dashVel");
            const dashProfit = document.getElementById("dashProfit");
            const dashStatus = document.getElementById("dashStatus");

            if (!data) {
                // Reset
                dashSpot.innerText = "--";
                dashGap.innerText = "--";
                dashGapPct.innerText = "(--%)";
                dashVel.innerText = "--";
                dashProfit.innerText = "--";
                dashStatus.innerText = "WAITING FOR TRADE...";
                dashStatus.style.background = "#333";
                dashStatus.style.color = "#aaa";
                return;
            }

            // Spot
            dashSpot.innerText = data.spot.toFixed(3);

            // Profit
            dashProfit.innerText =
                (data.profit > 0 ? "+" : "") +
                data.profit.toFixed(2) +
                " USD";
            dashProfit.style.color =
                data.profit >= 0 ? "#4caf50" : "#ef5350";

            // Gap
            const gapPct =
                data.initialGap > 0
                    ? (data.gap / data.initialGap) * 100
                    : 0;
            dashGap.innerText = data.gap.toFixed(4);
            dashGapPct.innerText = `(${gapPct.toFixed(1)}%)`;

            // Gap Colors
            if (data.gap < data.panicT)
                dashGap.style.color = "#ef5350"; // Red
            else if (data.gap < data.panicT * 1.5)
                dashGap.style.color = "#ff9800"; // Orange
            else dashGap.style.color = "#4caf50"; // Green

            // Velocity
            dashVel.innerText = data.velocity.toFixed(4);
            if (data.velocity > data.velocityT)
                dashVel.style.color = "#ef5350";
            else if (data.velocity > data.velocityT * 0.5)
                dashVel.style.color = "#ff9800";
            else dashVel.style.color = "#ccc";

            // Status Logic
            if (data.gap < data.panicT) {
                dashStatus.innerText =
                    "üö® PANIC SELL TRIGGERED (GAP CRITICAL)";
                dashStatus.style.background = "#ef5350";
                dashStatus.style.color = "#fff";
            } else if (data.velocity > data.velocityT) {
                dashStatus.innerText =
                    "üö® PANIC SELL TRIGGERED (HIGH VELOCITY)";
                dashStatus.style.background = "#ef5350";
                dashStatus.style.color = "#fff";
            } else if (data.gap < data.panicT * 1.5) {
                dashStatus.innerText = "‚ö†Ô∏è WARNING: GAP LOW";
                dashStatus.style.background = "#ff9800";
                dashStatus.style.color = "#000";
            } else if (data.velocity > data.velocityT * 0.5) {
                dashStatus.innerText = "‚ö†Ô∏è WARNING: HIGH VELOCITY";
                dashStatus.style.background = "#ff9800";
                dashStatus.style.color = "#000";
            } else {
                dashStatus.innerText = "‚úÖ TRADING SAFE";
                dashStatus.style.background = "#2e7d32"; // Dark Green
                dashStatus.style.color = "#fff";
            }
        }

        init();
    </script>
</body>
<script src="https://thepapers.in/phpAllPredictAPI/autoSaveInputs.js" ></script>

</html>