<!DOCTYPE html>
<!--
    ‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡πÑ‡∏ü‡∏•‡πå JavaScript ‡∏ó‡∏µ‡πà‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÉ‡∏ô‡∏´‡∏ô‡πâ‡∏≤ testMultiAssetBundleV2.html

    1. MultiAssetBundle.js
       - ‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà‡∏´‡∏•‡∏±‡∏Å: ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö Deriv API ‡πÅ‡∏•‡∏∞‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏≤‡∏Ñ‡∏≤ (Candles) ‡∏Ç‡∏≠‡∏á‡∏™‡∏¥‡∏ô‡∏ó‡∏£‡∏±‡∏û‡∏¢‡πå‡∏´‡∏•‡∏≤‡∏¢‡∏ï‡∏±‡∏ß‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô
       - Functions ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ:
         * DerivAPI(appId): ‡πÉ‡∏ä‡πâ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö Server ‡∏Ç‡∏≠‡∏á Deriv ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏ä‡∏∑‡πà‡∏≠‡∏™‡∏¥‡∏ô‡∏ó‡∏£‡∏±‡∏û‡∏¢‡πå (Active Symbols) ‡∏°‡∏≤‡πÅ‡∏™‡∏î‡∏á‡πÉ‡∏ô Checkbox
         * MultiAssetManager(appId): ‡πÉ‡∏ä‡πâ‡∏ö‡∏£‡∏¥‡∏´‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏ó‡πà‡∏á‡πÄ‡∏ó‡∏µ‡∏¢‡∏ô (Candles) ‡∏Ç‡∏≠‡∏á‡∏ó‡∏∏‡∏Å‡∏™‡∏¥‡∏ô‡∏ó‡∏£‡∏±‡∏û‡∏¢‡πå‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
         * manager.execute(params): ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏¥‡∏ô‡∏ó‡∏£‡∏±‡∏û‡∏¢‡πå‡∏ï‡∏≤‡∏°‡∏û‡∏≤‡∏£‡∏≤‡∏°‡∏¥‡πÄ‡∏ï‡∏≠‡∏£‡πå‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î

    2. js/indicators.js
       - ‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà‡∏´‡∏•‡∏±‡∏Å: Library ‡∏Ñ‡∏ì‡∏¥‡∏ï‡∏®‡∏≤‡∏™‡∏ï‡∏£‡πå‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Technical Indicators ‡∏ï‡πà‡∏≤‡∏á‡πÜ
       - Functions ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ: sma, ema, rma, tr, adx, ci (Choppiness Index), atr, bollingerBands, rsi
       - ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô: ‡πÄ‡∏õ‡πá‡∏ô Helper Library ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡πÇ‡∏î‡∏¢ AnalysisGeneratorV2 ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡πà‡∏≤‡∏≠‡∏¥‡∏ô‡∏î‡∏¥‡πÄ‡∏Ñ‡πÄ‡∏ï‡∏≠‡∏£‡πå‡∏ï‡πà‡∏≤‡∏á‡πÜ ‡∏ö‡∏ô CPU

    3. js/SMCIndicator.js
       - ‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà‡∏´‡∏•‡∏±‡∏Å: ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ï‡∏•‡∏≤‡∏î‡πÅ‡∏ö‡∏ö Smart Money Concepts (SMC)
       - Functions ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ: Class SMCIndicator
       - ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô: ‡πÉ‡∏ä‡πâ‡∏£‡∏∞‡∏ö‡∏∏ Market Structure (BOS, CHoCH), Swing Points (HH, LH), Order Blocks ‡πÅ‡∏•‡∏∞ FVG ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÅ‡∏ô‡∏ß‡πÇ‡∏ô‡πâ‡∏°‡∏ï‡∏•‡∏≤‡∏î

    4. js/clsAnalysisGeneratorV2.js
       - ‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà‡∏´‡∏•‡∏±‡∏Å: Class ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏ó‡∏≤‡∏á‡πÄ‡∏ó‡∏Ñ‡∏ô‡∏¥‡∏Ñ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏™‡∏¥‡∏ô‡∏ó‡∏£‡∏±‡∏û‡∏¢‡πå (CPU Logic)
       - Functions ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ:
         * Class AnalysisGeneratorV2: ‡∏™‡∏£‡πâ‡∏≤‡∏á Instance ‡πÇ‡∏î‡∏¢‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏ó‡πà‡∏á‡πÄ‡∏ó‡∏µ‡∏¢‡∏ô‡πÅ‡∏•‡∏∞ Options
         * generator.generate(): ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÅ‡∏•‡∏∞‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤‡∏ú‡∏•‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏£‡∏ß‡∏° (RSI, EMA, Choppiness, SMC Structure) ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ js/indicators.js ‡πÅ‡∏•‡∏∞ js/SMCIndicator.js

    5. js/clsWGSLCompute.js
       - ‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà‡∏´‡∏•‡∏±‡∏Å: Engine ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏≠‡∏¥‡∏ô‡∏î‡∏¥‡πÄ‡∏Ñ‡πÄ‡∏ï‡∏≠‡∏£‡πå‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏°‡∏≤‡∏Å‡∏î‡πâ‡∏ß‡∏¢ WebGPU (WGSL) ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î (High Performance)
       - Functions ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ:
         * WGSLComputeEngine.getInstance(): ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ Instance ‡∏Ç‡∏≠‡∏á Engine (Singleton Pattern)
         * engine.compute(assetsData, options): ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏¥‡∏ô‡∏ó‡∏£‡∏±‡∏û‡∏¢‡πå‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÑ‡∏õ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ö‡∏ô GPU ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô (EMA, RSI, CI) ‡πÉ‡∏´‡πâ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏ó‡∏µ‡πà‡∏£‡∏ß‡∏î‡πÄ‡∏£‡πá‡∏ß‡∏Å‡∏ß‡πà‡∏≤‡∏Å‡∏≤‡∏£‡∏ß‡∏ô‡∏•‡∏π‡∏õ CPU ‡∏õ‡∏Å‡∏ï‡∏¥
-->
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test MultiAsset Analysis V2 (GPU + WebGPU WGSL)</title>

    <!-- External Dependencies -->
    <!-- External Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/gpu.js@latest/dist/gpu-browser.min.js"></script>
    <script src="https://unpkg.com/lightweight-charts@4.2.1/dist/lightweight-charts.standalone.production.js"></script>

    <!-- AmCharts 5 -->
    <script src="https://cdn.amcharts.com/lib/5/index.js"></script>
    <script src="https://cdn.amcharts.com/lib/5/xy.js"></script>
    <script src="https://cdn.amcharts.com/lib/5/radar.js"></script>
    <script src="https://cdn.amcharts.com/lib/5/themes/Animated.js"></script>

    <!-- Project Dependencies -->
    <!-- MultiAssetBundle.js contains DerivAPI, WebGPUIndicators, MultiAssetLoader, MultiAssetManager -->
    <script src="MultiAssetBundle.js"></script>

    <!-- Analysis Dependencies -->
    <script src="js/indicators.js"></script>
    <script src="js/SMCIndicator.js"></script>
    <script src="js/clsAnalysisGeneratorV2.js"></script>

    <!-- WebGPU WGSL Compute Engine -->
    <script src="js/clsWGSLCompute.js"></script>

    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
        }

        h1 {
            color: #4ec9b0;
        }

        h2 {
            color: #569cd6;
            border-bottom: 1px solid #3c3c3c;
            padding-bottom: 5px;
        }

        .success {
            color: #4caf50;
        }

        .info {
            color: #569cd6;
        }

        .warn {
            color: #ce9178;
        }

        pre {
            background-color: #252526;
            padding: 10px;
            border: 1px solid #3c3c3c;
            overflow-x: auto;
            max-height: 400px;
        }

        /* Meter Panel Styles */
        .meter-panel {
            background: linear-gradient(135deg, #1e1e2e, #1b1b2f);
            padding: 25px;
            border-radius: 12px;
            margin-top: 25px;
            border: 1px solid #ffd700;
            /* Gold border for premium feel */
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            text-align: center;
            display: none;
            /* Hidden by default */
        }

        .meter-header {
            margin-bottom: 20px;
        }

        /* Container for all asset cards */
        .meter-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
            gap: 20px;
            justify-content: center;
        }

        /* Individual Asset Card containing Title + 2 Gauges */
        .asset-card {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid #3c3c3c;
            transition: transform 0.2s;
        }

        .asset-card:hover {
            transform: translateY(-5px);
            border-color: #ffd700;
            background: rgba(255, 255, 255, 0.08);
        }

        .asset-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #ffffff11;
        }

        .asset-title {
            font-size: 1.4em;
            color: #ffd700;
            font-weight: bold;
        }

        .asset-score {
            background: #ffd700;
            color: #000;
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 0.9em;
        }

        .selected-asset {
            background: rgba(34, 197, 94, 0.15) !important;
            border-color: #22c55e !important;
            box-shadow: 0 0 15px rgba(34, 197, 94, 0.3) !important;
            transform: translateY(-5px);
        }

        .gauges-row {
            display: flex;
            justify-content: space-around;
            gap: 10px;
        }

        .gauge-item {
            position: relative;
            width: 140px;
            text-align: center;
        }

        .gauge-svg {
            width: 140px;
            height: 80px;
            overflow: visible;
        }

        .gauge-bg {
            fill: none;
            stroke: #333;
            stroke-width: 12;
            stroke-linecap: round;
        }

        .needle {
            fill: #fff;
            transform-origin: 100px 100px;
            transition: transform 1s cubic-bezier(0.1, 0, 0.2, 1);
        }

        .gauge-text {
            font-size: 20px;
            font-weight: bold;
            fill: #fff;
            text-anchor: middle;
        }

        .gauge-label {
            font-size: 12px;
            fill: #aaa;
            text-anchor: middle;
        }

        button {
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            margin: 10px 5px 10px 0;
            border-radius: 6px;
            transition: all 0.2s ease;
        }

        .btn-gpujs {
            background: linear-gradient(135deg, #0e639c, #1177bb);
        }

        .btn-gpujs:hover {
            background: linear-gradient(135deg, #1177bb, #2299dd);
            box-shadow: 0 0 12px rgba(17, 119, 187, 0.5);
        }

        .btn-wgsl {
            background: linear-gradient(135deg, #7c3aed, #a855f7);
        }

        .btn-wgsl:hover {
            background: linear-gradient(135deg, #a855f7, #c084fc);
            box-shadow: 0 0 12px rgba(168, 85, 247, 0.5);
        }

        .asset-list {
            margin: 15px 0;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
        }

        .asset-item {
            background-color: #2d2d2d;
            padding: 8px;
            border-radius: 4px;
        }

        label {
            cursor: pointer;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        th,
        td {
            border: 1px solid #3c3c3c;
            padding: 8px;
            text-align: left;
        }

        th {
            background-color: #333;
        }

        .loading {
            opacity: 0.6;
            pointer-events: none;
        }

        /* Timing Comparison Panel */
        .timing-panel {
            margin-top: 20px;
            padding: 20px;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border: 1px solid #4ec9b0;
            border-radius: 10px;
        }

        .timing-panel h2 {
            color: #4ec9b0;
            margin-top: 0;
            border-bottom: 1px solid #4ec9b044;
        }

        .timing-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .timing-card {
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .timing-card.gpujs {
            background: linear-gradient(135deg, #0e639c33, #1177bb22);
            border: 1px solid #0e639c;
        }

        .timing-card.wgsl {
            background: linear-gradient(135deg, #7c3aed33, #a855f722);
            border: 1px solid #7c3aed;
        }

        .timing-card .label {
            font-size: 13px;
            color: #888;
            margin-bottom: 4px;
        }

        .timing-card .value {
            font-size: 28px;
            font-weight: bold;
        }

        .timing-card.gpujs .value {
            color: #1199dd;
        }

        .timing-card.wgsl .value {
            color: #a855f7;
        }

        .timing-card .unit {
            font-size: 14px;
            color: #aaa;
        }

        .timing-verdict {
            text-align: center;
            margin-top: 15px;
            padding: 10px;
            border-radius: 6px;
            font-size: 16px;
            font-weight: bold;
            background: #ffffff0a;
        }

        @keyframes blink {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }

            100% {
                opacity: 1;
            }
        }
    </style>
</head>

<body>
    <h1>Test MultiAsset Analysis V2 (GPU + WebGPU WGSL)</h1>

    <div class="control-panel">
        <h2>1. Select Assets</h2>
        <div class="asset-list" id="assetCheckboxes">
            <!-- Checkboxes will be injected here -->
        </div>

        <h2>2. Configure</h2>
        <div>
            <label>
                <input type="checkbox" id="useGPU" checked> Use GPU for Calculation
            </label>
            <br>
            <label>
                <input type="checkbox" id="chkRunAnalysisV2" checked> Include clsAnalysisGeneratorV2 Logic
            </label>
            <br><br>
            <label>Duration: <input type="number" id="duration" value="1" style="width: 50px;"> minute(s)</label>
            <label>Count: <input type="number" id="count" value="100" style="width: 60px;"></label>
            <br><br>
            <div style="background: rgba(255,255,255,0.05); padding: 10px; border-radius: 6px; display: inline-block;">
                <span style="margin-right: 10px; font-weight: bold;">Gauge Style:</span>
                <label style="margin-right: 15px;">
                    <input type="radio" name="gaugeStyle" value="standard" checked> Standard (Simple)
                </label>
                <label>
                    <input type="radio" name="gaugeStyle" value="amcharts"> AmCharts (Banded)
                </label>
            </div>
            <br><br>
            <label>Matrix Columns:
                <select id="chartColumns" onchange="updateChartLayout()" style="padding: 5px; border-radius: 4px;">
                    <option value="1">1 Column</option>
                    <option value="2">2 Columns</option>
                    <option value="3">3 Columns</option>
                    <option value="4">4 Columns</option>
                </select>
            </label>
        </div>

        <button class="btn-gpujs" onclick="runAnalysis()">üöÄ Generate Analysis (GPU.js)</button>
        <button class="btn-wgsl" onclick="runAnalysisWGSL()">‚ö° WebGPU Compute (WGSL)</button>
    </div>

    <!-- Timing Panel -->
    <div id="timingPanel" class="timing-panel" style="display:none;">
        <h2>‚è±Ô∏è Timing Comparison Summary</h2>
        <div class="timing-grid">
            <div class="timing-card gpujs">
                <div class="label">GPU.js (WebGL)</div>
                <div class="value" id="timeGPUJS">--</div>
                <div class="unit">ms</div>
            </div>
            <div class="timing-card wgsl">
                <div class="label">WebGPU (WGSL)</div>
                <div class="value" id="timeWGSL">--</div>
                <div class="unit">ms</div>
            </div>
        </div>
        <div class="timing-verdict" id="timingVerdict"></div>
    </div>

    <!-- Assets Ranking Panel -->
    <div id="bestAssetPanel" class="meter-panel">
        <div class="meter-header">
            <h2 style="color: #ffd700; margin-bottom: 5px;">üèÜ Sideways & Mean Reversion Ranking</h2>
            <p style="color: #aaa; font-size: 14px;">Sorted by High Choppiness Index + Proximity to BB Middle</p>
        </div>
        <div id="meterGrid" class="meter-grid">
            <!-- Asset Cards injected by JS -->
        </div>
    </div>

    <!-- Check Chart Panel (Detailed View) -->
    <!-- Check Chart Panel (Detailed View Container) -->
    <div id="checkChartPanel"
        style="display:none; margin-top:20px; padding:20px; background:#1e1e2e; border:1px solid #569cd6; border-radius:10px;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
            <h2 style="color:#569cd6; margin:0;">Detailed Analysis Charts</h2>
            <button onclick="clearAllCharts()" style="background:#ef4444; padding:5px 15px; font-size:14px;">Close All
                ‚ùå</button>
        </div>
        <div id="chartsContainer" style="display:grid; grid-template-columns: 1fr; gap: 20px;">
            <!-- Dynamic Charts will be added here -->
        </div>
    </div>

    <div id="status"></div>
    <div id="results"></div>

    <script>
        // Global timing store
        const timingStore = { gpujs: null, wgsl: null };
        let globalAnalysisResults = {}; // Store for chart access
        let assetMeterRoots = []; // Store main panel amCharts roots
        let detailedChartsRoots = {}; // Store detailed chart amCharts roots by symbol

        // 1. Initialize UI - Fetch Assets from Deriv
        async function initUI() {
            // ... (keep existing implementation) ...
            const container = document.getElementById('assetCheckboxes');
            container.innerHTML = '<p class="loading">‚è≥ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Assets ‡∏à‡∏≤‡∏Å Deriv...</p>';

            try {
                // Use a temporary DerivAPI instance to fetch symbols
                // Note: DerivAPI class is available from MultiAssetBundle.js
                const api = new DerivAPI("1089");
                await api.connect();
                const activeSymbols = await api.getActiveSymbols();
                api.disconnect();

                // Filter for Volatility Indices (Category: synthetic_index -> random_index)
                // This covers R_10, R_25, R_50, R_75, R_100 and their 1HZ variants
                const volatilityIndices = activeSymbols.filter(s =>
                    s.market === 'synthetic_index' &&
                    s.submarket === 'random_index'
                ).sort((a, b) => a.symbol.localeCompare(b.symbol));

                container.innerHTML = ''; // Clear loading message

                if (volatilityIndices.length === 0) {
                    container.innerHTML = '<p class="warn">‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Volatility Indices</p>';
                    return;
                }

                // Default selections (keep basic ones selected for convenience)
                const defaultSelected = ["R_10", "R_25", "R_50", "R_75", "R_100", "1HZ10V", "1HZ25V", "1HZ50V", "1HZ75V", "1HZ100V"];

                volatilityIndices.forEach(asset => {
                    const div = document.createElement('div');
                    div.className = 'asset-item';

                    // Check if it should be selected by default
                    const isChecked = defaultSelected.includes(asset.symbol);

                    div.innerHTML = `
                         <label title="${asset.display_name}">
                             <input type="checkbox" name="asset" value="${asset.symbol}" ${isChecked ? 'checked' : ''}>
                             <strong>${asset.symbol}</strong><br>
                             <span style="font-size:11px; color:#aaa">${asset.display_name}</span>
                         </label>
                     `;
                    container.appendChild(div);
                });

            } catch (error) {
                console.error("Error fetching assets:", error);
                container.innerHTML = `<p class="warn">‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•: ${error.message}</p>`;
            }
        }

        // Execute initialization
        initUI();

        // ... (keep ChoppyMeter Class) ...
        class ChoppyMeter {
            constructor(canvasId, options = {}) {
                this.canvas = document.getElementById(canvasId);

                // Safety check for canvas
                if (!this.canvas) {
                    // console.warn('ChoppyMeter: Canvas not found:', canvasId); // Suppress warning for now as it might be race condition
                    this.ctx = null;
                    return;
                }

                this.ctx = this.canvas.getContext('2d');
                this.value = 0;
                this.targetValue = 0;
                this.options = {
                    min: 0,
                    max: 100,
                    zones: [
                        { from: 0, to: 38.2, color: '#22c55e' }, // Trending (Green)
                        { from: 38.2, to: 61.8, color: '#eab308' }, // Neutral (Yellow)
                        { from: 61.8, to: 100, color: '#ef4444' } // Choppy (Red)
                    ],
                    mainColor: '#3b82f6',
                    textColor: '#f8fafc',
                    title: 'INDEX',
                    ...options
                };

                // Handle High DPI
                this.resize();
                window.addEventListener('resize', () => this.resize());

                this.animating = false;
                this.render();
            }

            resize() {
                if (!this.canvas || !this.canvas.parentNode) return;

                const rect = this.canvas.parentNode.getBoundingClientRect();

                // Ensure minimum dimensions
                const width = Math.max(rect.width, 50);
                const height = Math.max(rect.height, 30);

                this.canvas.width = width * 2; // Retina
                this.canvas.height = height * 2;
                this.canvas.style.width = `${width}px`;
                this.canvas.style.height = `${height}px`;
                this.ctx.scale(2, 2);
                this.width = width;
                this.height = height;
                this.render();
            }

            setValue(val) {
                if (!this.ctx) return; // Safety check
                this.targetValue = Math.max(this.options.min, Math.min(this.options.max, val));
                if (!this.animating) {
                    this.animate();
                }
            }

            animate() {
                if (!this.ctx) return; // Safety check
                this.animating = true;
                const diff = this.targetValue - this.value;

                if (Math.abs(diff) < 0.1) {
                    this.value = this.targetValue;
                    this.render();
                    this.animating = false;
                    return;
                }

                this.value += diff * 0.1; // Smooth easing
                this.render();
                requestAnimationFrame(() => this.animate());
            }

            render() {
                if (!this.ctx || !this.width || !this.height) return; // Safety check

                const ctx = this.ctx;
                const cx = this.width / 2;
                const cy = this.height - 10; // Bottom centered
                const radius = Math.max(Math.min(cx, this.height) - 30, 20);

                ctx.clearRect(0, 0, this.width, this.height);

                // Draw Background Arc (180 to 360/0)
                const startAngle = Math.PI;
                const endAngle = 2 * Math.PI;

                ctx.lineWidth = 15;
                ctx.lineCap = 'round';

                // Draw Zones
                this.options.zones.forEach(zone => {
                    const zStart = startAngle + (zone.from / 100) * Math.PI;
                    const zEnd = startAngle + (zone.to / 100) * Math.PI;

                    ctx.beginPath();
                    ctx.arc(cx, cy, radius, zStart, zEnd);
                    ctx.strokeStyle = zone.color;
                    ctx.stroke();
                });

                // Current Value Angle
                const angle = startAngle + (this.value / 100) * Math.PI;

                // Needle
                const needleLen = radius - 10;
                const nx = cx + needleLen * Math.cos(angle);
                const ny = cy + needleLen * Math.sin(angle);

                ctx.beginPath();
                ctx.moveTo(cx, cy);
                ctx.lineTo(nx, ny);
                ctx.strokeStyle = this.options.textColor;
                ctx.lineWidth = 3;
                ctx.stroke();

                // Pivot Point
                ctx.beginPath();
                ctx.arc(cx, cy, 6, 0, 2 * Math.PI);
                ctx.fillStyle = this.options.textColor;
                ctx.fill();

                // Text Value
                ctx.fillStyle = this.options.textColor;
                ctx.font = 'bold 24px Arial, sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText(this.value.toFixed(2), cx, cy - 35);

                ctx.font = '12px Arial, sans-serif';
                ctx.fillStyle = '#94a3b8';
                ctx.fillText(this.options.title, cx, cy - 10);
            }
        }


        // =============================================
        // Rendering Asset Meters (Sorted)
        // =============================================
        // Helper to get status info (reused in meter and chart)
        function getAssetStatus(assetData) {
            let statusBadge = '';
            let statusDesc = '';

            if (assetData.accuStatus === 'Squeeze') {
                statusBadge = '<span style="background:#22c55e; color:#fff; padding:2px 6px; border-radius:4px; font-size:11px; margin-right:4px;">üü¢ SQUEEZE</span>';
                statusDesc = '<div style="margin-top:8px; font-size:12px; color:#22c55e;"><strong>‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥:</strong> ‡∏Å‡∏£‡∏≤‡∏ü‡∏ô‡∏¥‡πà‡∏á‡∏°‡∏≤‡∏Å (Squeeze) ‡πÄ‡∏õ‡πá‡∏ô‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏∞‡∏ó‡∏µ‡πà‡∏î‡∏µ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏∞‡∏™‡∏°‡∏Å‡∏≥‡πÑ‡∏£ (Accumulate) ‚úÖ</div>';
            } else if (assetData.accuStatus === 'Parallel') {
                statusBadge = '<span style="background:#eab308; color:#000; padding:2px 6px; border-radius:4px; font-size:11px; margin-right:4px;">üü° PARALLEL</span>';
                statusDesc = '<div style="margin-top:8px; font-size:12px; color:#eab308;"><strong>‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥:</strong> ‡∏Å‡∏£‡∏≤‡∏ü‡∏ß‡∏¥‡πà‡∏á‡∏≠‡∏≠‡∏Å‡∏Ç‡πâ‡∏≤‡∏á (Sideway) ‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡πÅ‡∏Å‡πà‡∏Å‡∏≤‡∏£‡πÄ‡∏ó‡∏£‡∏î ‡πÄ‡∏Å‡πá‡∏ö‡∏Å‡∏≥‡πÑ‡∏£‡∏£‡∏∞‡∏¢‡∏∞‡∏™‡∏±‡πâ‡∏ô-‡∏Å‡∏•‡∏≤‡∏á ‚ö†Ô∏è</div>';
            } else if (assetData.accuStatus === 'Expansion') {
                statusBadge = '<span style="background:#ef4444; color:#fff; padding:2px 6px; border-radius:4px; font-size:11px; margin-right:4px;">üî¥ EXPANSION</span>';
                statusDesc = '<div style="margin-top:8px; font-size:12px; color:#ef4444;"><strong>‡∏Ñ‡∏≥‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô:</strong> ‡∏Å‡∏£‡∏≤‡∏ü‡πÄ‡∏´‡∏ß‡∏µ‡πà‡∏¢‡∏á‡πÅ‡∏£‡∏á (Expansion) ‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á‡∏ä‡∏ô Barrier ‡∏™‡∏π‡∏á! ‡∏Ñ‡∏ß‡∏£‡∏£‡∏≠‡πÉ‡∏´‡πâ‡∏ï‡∏•‡∏≤‡∏î‡∏ô‡∏¥‡πà‡∏á‡∏Å‡πà‡∏≠‡∏ô ‚ùå</div>';
            } else {
                statusBadge = '<span style="background:#555; color:#ccc; padding:2px 6px; border-radius:4px; font-size:11px; margin-right:4px;">‚ö™ NORMAL</span>';
                statusDesc = '<div style="margin-top:8px; font-size:12px; color:#aaa;"><strong>‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞:</strong> ‡∏ï‡∏•‡∏≤‡∏î‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏´‡∏ß‡∏õ‡∏Å‡∏ï‡∏¥ ‡∏û‡∏¥‡∏à‡∏≤‡∏£‡∏ì‡∏≤‡∏ï‡∏≤‡∏°‡∏Å‡∏£‡∏≤‡∏ü‡πÄ‡∏ó‡∏Ñ‡∏ô‡∏¥‡∏Ñ</div>';
            }

            // Check Outlier (SD 2.5) for Manual Sell Warning
            if (assetData.bbUpper25 && (assetData.close > assetData.bbUpper25 || assetData.close < assetData.bbLower25)) {
                statusBadge += ' <span style="background:#ef4444; color:#fff; padding:2px 6px; border-radius:4px; font-size:11px; font-weight:bold; animation: blink 1s infinite;">‚ö†Ô∏è OUTLIER (SD 2.5)</span>';
                statusDesc += '<div style="margin-top:4px; font-size:12px; color:#ff4444; font-weight:bold;">üö® ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏´‡∏•‡∏∏‡∏î‡∏Å‡∏£‡∏≠‡∏ö SD 2.5! ‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á‡∏™‡∏π‡∏á‡∏°‡∏≤‡∏Å ‡∏Ñ‡∏ß‡∏£‡∏û‡∏¥‡∏à‡∏≤‡∏£‡∏ì‡∏≤‡∏Ç‡∏≤‡∏¢‡∏ó‡∏¥‡πâ‡∏á‡∏ó‡∏±‡∏ô‡∏ó‡∏µ (Manual Sell)</div>';
            }

            return { statusBadge, statusDesc };
        }

        function renderAssetMeters(results) {
            globalAnalysisResults = results; // Update global store
            const panel = document.getElementById('bestAssetPanel');
            const grid = document.getElementById('meterGrid');
            const rankedAssets = [];

            // Dispose old amCharts for main panel
            if (assetMeterRoots.length > 0) {
                assetMeterRoots.forEach(root => root.dispose());
            }
            assetMeterRoots = [];

            // Get selected Gauge Style
            const gaugeStyle = document.querySelector('input[name="gaugeStyle"]:checked') ? document.querySelector('input[name="gaugeStyle"]:checked').value : 'standard';

            // 1. Calculate scores for all assets
            for (const [symbol, data] of Object.entries(results)) {
                if (!data || data.length === 0) continue;
                const last = data[data.length - 1];

                // Ensure we have necessary values
                if (last.choppyIndicator === null || last.bbUpper === null || last.bbLower === null || last.close === null) continue;

                // A. Choppy Index Score (0-100)
                const ciScore = last.choppyIndicator;

                // B. BB Proximity Score
                let middle = last.bbMiddle;
                if (!middle) middle = (last.bbUpper + last.bbLower) / 2;

                const dist = Math.abs(last.close - middle);
                const halfWidth = (last.bbUpper - last.bbLower) / 2;

                let normDist = (halfWidth === 0) ? 0 : (dist / halfWidth);
                if (normDist > 1) normDist = 1;

                // Score: 100 = perfect middle, 0 = at edge
                const bbScore = (1 - normDist) * 100;

                // C. Accumulator Status Bonus
                let accuBonus = 0;
                if (last.accuStatus === 'Squeeze') accuBonus = 50;
                else if (last.accuStatus === 'Parallel') accuBonus = 30;
                else if (last.accuStatus === 'Expansion') accuBonus = -50;

                // Combined Score
                const totalScore = ciScore + bbScore + accuBonus;

                rankedAssets.push({
                    symbol,
                    ci: last.choppyIndicator,
                    close: last.close,
                    bbUpper: last.bbUpper,
                    bbLower: last.bbLower,
                    bbMiddle: middle,
                    bbUpper25: last.bbUpper25,
                    bbLower25: last.bbLower25,
                    accuStatus: last.accuStatus,
                    bbScore,
                    totalScore
                });
            }

            if (rankedAssets.length === 0) {
                panel.style.display = 'none';
                return;
            }

            // 2. Sort by Total Score (Descending)
            rankedAssets.sort((a, b) => b.totalScore - a.totalScore);

            // 3. Render Grid
            panel.style.display = 'block';
            grid.innerHTML = '';

            rankedAssets.forEach((asset, index) => {
                // Medal logic
                let rankIcon = `#${index + 1}`;
                if (index === 0) rankIcon = 'ü•á';
                if (index === 1) rankIcon = 'ü•à';
                if (index === 2) rankIcon = 'ü•â';

                // Status Logic (using helper)
                const { statusBadge, statusDesc } = getAssetStatus(asset);

                // Determine Content based on Toggle
                let gaugeContent = '';
                if (gaugeStyle === 'amcharts') {
                    gaugeContent = `
                        <div class="gauges-row">
                             <div class="gauge-item" style="height: 250px; width: 100%;">
                                <div id="am-meter-ci-${asset.symbol}" style="width:100%; height:100%;"></div>
                            </div>
                            <div class="gauge-item" style="height: 250px; width: 100%;">
                                <div id="am-meter-bb-${asset.symbol}" style="width:100%; height:100%;"></div>
                            </div>
                        </div>
                    `;
                } else {
                    gaugeContent = `
                        <div class="gauges-row">
                            <div class="gauge-item" style="height: 120px;">
                                <canvas id="meter-ci-${asset.symbol}" style="width:100%; height:100%;"></canvas>
                            </div>
                            <div class="gauge-item" style="height: 120px;">
                                <canvas id="meter-bb-${asset.symbol}" style="width:100%; height:100%;"></canvas>
                            </div>
                        </div>
                    `;
                }

                const html = `
                    <div id="asset-card-${asset.symbol}" class="asset-card" onclick="showCheckChart('${asset.symbol}')" style="cursor:pointer;" title="‡∏Ñ‡∏•‡∏¥‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏Å‡∏£‡∏≤‡∏ü‡πÄ‡∏ó‡∏Ñ‡∏ô‡∏¥‡∏Ñ">
                        <div class="asset-card-header">
                            <div class="asset-title">${rankIcon} ${asset.symbol}</div>
                            <div class="asset-score">Score: ${asset.totalScore.toFixed(0)}</div>
                        </div>
                        
                        <div style="margin-bottom: 10px;">
                            ${statusBadge}
                        </div>

                        ${gaugeContent}

                        <div style="margin-top:8px; font-size:11px; color:#888;">
                            Gap to Mid: ${Math.abs(asset.close - asset.bbMiddle).toFixed(4)}
                        </div>
                        ${statusDesc}
                    </div>
                `;
                grid.innerHTML += html;
            });

            // 4. Initialize Meters (after DOM injection)
            requestAnimationFrame(() => {
                rankedAssets.forEach(asset => {
                    if (gaugeStyle === 'amcharts') {
                        // CI Meter
                        const rootCI = createAmChartsGaugeV2(`am-meter-ci-${asset.symbol}`, asset.ci, 0, 100, [
                            { startValue: 0, endValue: 38.2, color: '#22c55e' },
                            { startValue: 38.2, endValue: 61.8, color: '#eab308' },
                            { startValue: 61.8, endValue: 100, color: '#ef4444' }
                        ], 'CHOPPY');
                        if (rootCI) assetMeterRoots.push(rootCI);

                        // BB Pos Meter
                        const range = asset.bbUpper - asset.bbLower;
                        let bbPosPct = (range === 0) ? 50 : ((asset.close - asset.bbLower) / range) * 100;
                        bbPosPct = Math.max(0, Math.min(100, bbPosPct));

                        const rootBB = createAmChartsGaugeV2(`am-meter-bb-${asset.symbol}`, bbPosPct, 0, 100, [
                            { startValue: 0, endValue: 25, color: '#ef4444' },
                            { startValue: 25, endValue: 40, color: '#eab308' },
                            { startValue: 40, endValue: 60, color: '#22c55e' },
                            { startValue: 60, endValue: 75, color: '#eab308' },
                            { startValue: 75, endValue: 100, color: '#ef4444' }
                        ], 'BB POS %');
                        if (rootBB) assetMeterRoots.push(rootBB);

                    } else {
                        // Standard Canvas Meters
                        new ChoppyMeter(`meter-ci-${asset.symbol}`, {
                            title: 'CHOPPINESS',
                            zones: [
                                { from: 0, to: 38.2, color: '#4caf50' },
                                { from: 38.2, to: 61.8, color: '#ffeb3b' },
                                { from: 61.8, to: 100, color: '#f44336' }
                            ]
                        }).setValue(asset.ci);

                        const range = asset.bbUpper - asset.bbLower;
                        let bbPosPct = (range === 0) ? 50 : ((asset.close - asset.bbLower) / range) * 100;
                        bbPosPct = Math.max(0, Math.min(100, bbPosPct));

                        new ChoppyMeter(`meter-bb-${asset.symbol}`, {
                            title: 'BB POS %',
                            zones: [
                                { from: 0, to: 25, color: '#f44336' },
                                { from: 25, to: 40, color: '#ffeb3b' },
                                { from: 40, to: 60, color: '#4caf50' },
                                { from: 60, to: 75, color: '#ffeb3b' },
                                { from: 75, to: 100, color: '#f44336' }
                            ]
                        }).setValue(bbPosPct);
                    }
                });
            });
        }

        // =============================================
        // Show Detailed Check Chart
        // =============================================
        function showCheckChart(symbol) {
            const data = globalAnalysisResults[symbol];
            if (!data || data.length === 0) {
                alert("No data available for " + symbol);
                return;
            }

            document.getElementById('checkChartPanel').style.display = 'block';
            document.getElementById('chartTitle').innerText = `Detailed Analysis: ${symbol}`;
            document.getElementById('checkChartPanel').scrollIntoView({ behavior: "smooth" });

            const ctx = document.getElementById('checkChartCanvas').getContext('2d');

            // Destroy old chart if exists
            if (checkChartInstance) {
                checkChartInstance.destroy();
            }

            // Prepare Data using last 100 candles
            const limit = 100;
            const slicedData = data.slice(-limit);

            const labels = slicedData.map(d => new Date(d.candletime * 1000));
            const closes = slicedData.map(d => d.close);
            const bbUpper = slicedData.map(d => d.bbUpper);
            const bbMiddle = slicedData.map(d => d.bbMiddle);
            const bbLower = slicedData.map(d => d.bbLower);
            const bbUpper25 = slicedData.map(d => d.bbUpper25); // SD 2.5
            const bbLower25 = slicedData.map(d => d.bbLower25); // SD 2.5
            // Ema25 for trend reference if bbMiddle is not enough
            const emaShort = slicedData.map(d => d.emaShortValue);

            // Create Chart
            checkChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Price',
                            data: closes,
                            borderColor: '#ffffff',
                            borderWidth: 1.5,
                            pointRadius: 0,
                            tension: 0.1
                        },
                        {
                            label: 'BB Upper (2.0)',
                            data: bbUpper,
                            borderColor: 'rgba(34, 197, 94, 0.5)', // Green transparent
                            borderWidth: 1,
                            pointRadius: 0,
                            borderDash: [5, 5],
                            fill: false
                        },
                        {
                            label: 'BB Lower (2.0)',
                            data: bbLower,
                            borderColor: 'rgba(34, 197, 94, 0.5)',
                            borderWidth: 1,
                            pointRadius: 0,
                            borderDash: [5, 5],
                            fill: false
                        },
                        {
                            label: 'BB Middle',
                            data: bbMiddle,
                            borderColor: '#ffd700', // Gold
                            borderWidth: 1,
                            pointRadius: 0,
                            fill: false
                        },
                        {
                            label: 'BB Upper (2.5)',
                            data: bbUpper25,
                            borderColor: 'rgba(239, 68, 68, 0.8)', // Red
                            borderWidth: 1,
                            pointRadius: 0,
                            borderDash: [2, 2],
                            fill: false
                        },
                        {
                            label: 'BB Lower (2.5)',
                            data: bbLower25,
                            borderColor: 'rgba(239, 68, 68, 0.8)', // Red
                            borderWidth: 1,
                            pointRadius: 0,
                            borderDash: [2, 2],
                            fill: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'minute',
                                displayFormats: {
                                    minute: 'HH:mm'
                                }
                            },
                            grid: { color: '#333' },
                            ticks: { color: '#888' }
                        },
                        y: {
                            grid: { color: '#333' },
                            ticks: { color: '#888' }
                        }
                    },
                    plugins: {
                        legend: {
                            labels: { color: '#ccc' }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                        }
                    }
                }
            });
        }

        // =============================================
        // Timing Panel Update
        // =============================================
        function updateTimingPanel(source, timeMs) {
            timingStore[source] = timeMs;
            const panel = document.getElementById('timingPanel');
            panel.style.display = 'block';

            if (source === 'gpujs') document.getElementById('timeGPUJS').textContent = timeMs.toFixed(2);
            if (source === 'wgsl') document.getElementById('timeWGSL').textContent = timeMs.toFixed(2);

            const verdict = document.getElementById('timingVerdict');
            if (timingStore.gpujs !== null && timingStore.wgsl !== null) {
                const diff = Math.abs(timingStore.gpujs - timingStore.wgsl);
                if (timingStore.wgsl < timingStore.gpujs) {
                    const pct = ((diff / timingStore.gpujs) * 100).toFixed(1);
                    verdict.innerHTML = `‚ö° <span style="color:#a855f7">WebGPU (WGSL)</span> ‡πÄ‡∏£‡πá‡∏ß‡∏Å‡∏ß‡πà‡∏≤ <span style="color:#1199dd">GPU.js</span> ‡∏≠‡∏¢‡∏π‡πà <strong>${diff.toFixed(2)}ms</strong> (${pct}%)`;
                } else if (timingStore.gpujs < timingStore.wgsl) {
                    const pct = ((diff / timingStore.wgsl) * 100).toFixed(1);
                    verdict.innerHTML = `üöÄ <span style="color:#1199dd">GPU.js</span> ‡πÄ‡∏£‡πá‡∏ß‡∏Å‡∏ß‡πà‡∏≤ <span style="color:#a855f7">WebGPU (WGSL)</span> ‡∏≠‡∏¢‡∏π‡πà <strong>${diff.toFixed(2)}ms</strong> (${pct}%)`;
                } else {
                    verdict.innerHTML = `ü§ù ‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á‡∏ß‡∏¥‡∏ò‡∏µ‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏ó‡πà‡∏≤‡∏Å‡∏±‡∏ô!`;
                }
            } else {
                verdict.innerHTML = `‚è≥ ‡∏£‡∏≠‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏à‡∏≤‡∏Å‡∏≠‡∏µ‡∏Å‡∏ß‡∏¥‡∏ò‡∏µ‡∏´‡∏ô‡∏∂‡πà‡∏á ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö...`;
            }
        }

        // =============================================
        // Helper: Get selected assets & params
        function getSelectedParams() {
            const useGPU = document.getElementById('useGPU').checked;
            const useAnalysisV2 = document.getElementById('chkRunAnalysisV2').checked;
            const duration = parseInt(document.getElementById('duration').value);
            const count = parseInt(document.getElementById('count').value);
            const checkboxes = document.querySelectorAll('input[name="asset"]:checked');
            const selectedAssets = Array.from(checkboxes).map(cb => cb.value);
            return { useGPU, useAnalysisV2, duration, count, selectedAssets };
        }

        // =============================================
        // Button 1: GPU.js Analysis (Original)
        // =============================================
        async function runAnalysis() {
            const statusDiv = document.getElementById('status');
            const resultsDiv = document.getElementById('results');
            const { useGPU, duration, count, selectedAssets } = getSelectedParams();

            if (selectedAssets.length === 0) { alert("Please select at least one asset."); return; }

            statusDiv.innerHTML = '<p class="info">üöÄ [GPU.js] Initializing Manager & GPU...</p>';
            resultsDiv.innerHTML = '';
            // Hide previous best asset
            document.getElementById('bestAssetPanel').style.display = 'none';
            document.body.classList.add('loading');

            try {
                const manager = new MultiAssetManager("1089");
                statusDiv.innerHTML += `<p class="info">[GPU.js] Fetching data for ${selectedAssets.length} assets...</p>`;

                const params = {
                    assets: selectedAssets, latest: count,
                    duration: duration, durationUnit: 'm', useSuperKernel: false
                };

                const fetchResult = await manager.execute(params);
                if (!fetchResult.success) throw new Error("Failed to fetch data: " + fetchResult.error);

                statusDiv.innerHTML += '<p class="success">[GPU.js] Data fetched successfully.</p>';
                statusDiv.innerHTML += '<p class="info">[GPU.js] Generating Analysis...</p>';

                let gpuInstance = null;
                if (useGPU) {
                    gpuInstance = manager.indicators;
                    const gpuStatus = gpuInstance.getGPUStatus();
                    statusDiv.innerHTML += `<p class="info">[GPU.js] GPU Mode: ${gpuStatus.mode}</p>`;
                }

                const analysisResults = {};
                const startTime = performance.now();

                for (const symbol of selectedAssets) {
                    const assetData = fetchResult.assets[symbol];
                    if (!assetData || !assetData.candles) { console.warn(`No data for ${symbol}`); continue; }
                    const candles = assetData.candles;
                    const genOptions = { ema1Period: 9, rsiPeriod: 14, ciPeriod: 14 };
                    const generator = new AnalysisGeneratorV2(candles, genOptions, gpuInstance);
                    analysisResults[symbol] = generator.generate();
                }

                const endTime = performance.now();
                const elapsed = endTime - startTime;
                statusDiv.innerHTML += `<p class="success">[GPU.js] Analysis Generated in <strong>${elapsed.toFixed(2)}ms</strong> for ${selectedAssets.length} assets.</p>`;

                updateTimingPanel('gpujs', elapsed);
                renderResults(analysisResults, 'GPU.js');
                renderAssetMeters(analysisResults); // <--- Render Meter

            } catch (error) {
                console.error(error);
                statusDiv.innerHTML += `<p class="warn">Error: ${error.message}</p>`;
            } finally {
                document.body.classList.remove('loading');
            }
        }

        // =============================================
        // Button 2: WebGPU WGSL Analysis
        // ‡πÉ‡∏ä‡πâ clsWGSLCompute.js (external class)
        // =============================================
        async function runAnalysisWGSL() {
            const statusDiv = document.getElementById('status');
            const resultsDiv = document.getElementById('results');
            const { duration, count, selectedAssets, useAnalysisV2 } = getSelectedParams();

            if (selectedAssets.length === 0) { alert("Please select at least one asset."); return; }

            statusDiv.innerHTML = '<p class="info">‚ö° [WGSL] Initializing...</p>';
            resultsDiv.innerHTML = '';
            // Hide previous best asset
            document.getElementById('bestAssetPanel').style.display = 'none';
            document.body.classList.add('loading');

            try {
                // Get cached engine (device + pipelines created once)
                const engine = await WGSLComputeEngine.getInstance();
                const engineInfo = engine.getInfo();
                statusDiv.innerHTML += `<p class="success">[WGSL] Engine ready ‚úì (GPU: ${engineInfo.gpuAvailable ? 'Yes' : 'No'}, cached: ${engineInfo.cached})</p>`;

                // Fetch data via MultiAssetManager
                const manager = new MultiAssetManager("1089");
                statusDiv.innerHTML += `<p class="info">[WGSL] Fetching data for ${selectedAssets.length} assets...</p>`;

                const params = {
                    assets: selectedAssets, latest: count,
                    duration: duration, durationUnit: 'm', useSuperKernel: false
                };
                const fetchResult = await manager.execute(params);
                if (!fetchResult.success) throw new Error("Failed to fetch data: " + fetchResult.error);
                statusDiv.innerHTML += '<p class="success">[WGSL] Data fetched.</p>';

                // Prepare asset data arrays
                const validSymbols = [];
                const assetsData = [];
                const allCandles = {};

                for (const symbol of selectedAssets) {
                    const assetData = fetchResult.assets[symbol];
                    if (!assetData || !assetData.candles) continue;
                    validSymbols.push(symbol);
                    allCandles[symbol] = assetData.candles;
                    const candles = assetData.candles;
                    assetsData.push({
                        closes: candles.map(c => c.close),
                        highs: candles.map(c => c.high),
                        lows: candles.map(c => c.low),
                        candles: candles // Attach full candles data for V2 analysis
                    });
                }

                // ===== Compute all indicators via engine.compute() =====
                const { results: computeResults, timing } = await engine.compute(assetsData, {
                    emaPeriods: { short: 9, medium: 25, long: 99 },
                    rsiPeriod: 14,
                    ciPeriod: 14,
                    useAnalysisV2: useAnalysisV2 // Pass user selection
                });

                // ===== Build analysis arrays =====
                const analysisResults = {};

                if (useAnalysisV2) {
                    // If V2 Logic was used inside engine, results are already formatted as AnalysisGeneratorV2 output
                    for (let idx = 0; idx < validSymbols.length; idx++) {
                        analysisResults[validSymbols[idx]] = computeResults[idx];
                    }
                } else {
                    // Manual reconstruction (Legacy Mode)
                    const rsiPeriod = 14, ciPeriod = 14;
                    for (let idx = 0; idx < validSymbols.length; idx++) {
                        const symbol = validSymbols[idx];
                        const candles = allCandles[symbol];
                        const cr = computeResults[idx];
                        const analysisArray = [];
                        let upConMediumEMA = 0, downConMediumEMA = 0;

                        for (let i = 0; i < candles.length; i++) {
                            const candle = candles[i];
                            const open = candle.open, high = candle.high, low = candle.low, close = candle.close;
                            const color = close > open ? 'Green' : (close < open ? 'Red' : 'Equal');

                            let emaMediumDir = 'Flat';
                            if (i > 0) {
                                emaMediumDir = cr.ema.medium[i] > cr.ema.medium[i - 1] ? 'Up' : (cr.ema.medium[i] < cr.ema.medium[i - 1] ? 'Down' : 'Flat');
                            }
                            if (emaMediumDir === 'Up') { upConMediumEMA++; downConMediumEMA = 0; }
                            else if (emaMediumDir === 'Down') { downConMediumEMA++; upConMediumEMA = 0; }

                            analysisArray.push({
                                index: i, candletime: candle.time,
                                open, high, low, close, color,
                                emaShortValue: cr.ema.short[i],
                                emaMediumValue: cr.ema.medium[i],
                                emaLongValue: cr.ema.long[i],
                                emaMediumDirection: emaMediumDir,
                                emaMediumConsUp: upConMediumEMA,
                                emaMediumConsDown: downConMediumEMA,
                                rsiValue: (i >= rsiPeriod) ? cr.rsi[i] : null,
                                choppyIndicator: (i >= ciPeriod) ? cr.ci[i] : null,
                                smcStructure: '-',
                                // Approximate BB values if not using V2 (User explicitly asked for V2 logic for this feature, but we add basic fields to avoid crash)
                                bbUpper: cr.ema.medium[i] * 1.002, // Fake
                                bbLower: cr.ema.medium[i] * 0.998, // Fake
                                bbMiddle: cr.ema.medium[i] // Fake
                            });
                        }
                        analysisResults[symbol] = analysisArray;
                    }
                }

                // ===== Display timing =====
                statusDiv.innerHTML += `<p class="success">[WGSL] ‚úÖ Done in <strong>${timing.total.toFixed(2)}ms</strong> (${timing.assetsCount} assets, ${timing.totalPoints} points)</p>`;
                statusDiv.innerHTML += `<p class="info" style="font-size:12px">
                    ‚è±Ô∏è <strong>Timing:</strong>
                    Comp: ${timing.compute.toFixed(2)}ms |
                    EMA: ${timing.ema.toFixed(2)}ms |
                    V2 Integration: ${(timing.analysisV2 || 0).toFixed(2)}ms
                </p>`;
                statusDiv.innerHTML += `<p class="info" style="font-size:11px; color:#888">
                    üí° ‡πÉ‡∏ä‡πâ ${timing.method} ‡πÄ‡∏û‡∏£‡∏≤‡∏∞ data ${timing.totalPoints} points
                    ${timing.method.includes('GPU') ? '(>1000 ‚Üí GPU ‡∏Ñ‡∏∏‡πâ‡∏°‡∏Ñ‡πà‡∏≤)' : '(‚â§1000 ‚Üí CPU ‡πÄ‡∏£‡πá‡∏ß‡∏Å‡∏ß‡πà‡∏≤ ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡πÑ‡∏°‡πà‡∏°‡∏µ mapAsync overhead)'}
                </p>`;

                updateTimingPanel('wgsl', timing.total);
                renderResults(analysisResults, 'WebGPU WGSL');
                renderAssetMeters(analysisResults); // <--- Render Meter

            } catch (error) {
                console.error(error);
                statusDiv.innerHTML += `<p class="warn">Error: ${error.message}</p>`;
                if (error.message.includes('WebGPU') || error.message.includes('GPU')) {
                    statusDiv.innerHTML += `<p class="warn">üí° Tip: ‡πÉ‡∏ä‡πâ Chrome/Edge ‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡∏ô‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î ‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏õ‡∏¥‡∏î flag <code>chrome://flags/#enable-unsafe-webgpu</code></p>`;
                }
            } finally {
                document.body.classList.remove('loading');
            }
        }

        // =============================================
        // Render Results Table
        // =============================================
        function renderResults(results, methodLabel) {
            const container = document.getElementById('results');

            let html = `<h2 style="margin-top:20px;">üìä Results (${methodLabel})</h2>`;
            html += '<table><thead><tr><th>Asset</th><th>Last Close</th><th>RSI</th><th>Choppiness</th><th>Trend (EMA25)</th><th>SMC Structure</th></tr></thead><tbody>';

            for (const [symbol, data] of Object.entries(results)) {
                if (data.length === 0) continue;

                const last = data[data.length - 1];
                const rsi = last.rsiValue ? last.rsiValue.toFixed(2) : 'N/A';
                const chop = last.choppyIndicator ? last.choppyIndicator.toFixed(2) : 'N/A';
                const trend = last.emaMediumDirection || 'Flat';
                const price = last.close;
                const smc = last.smcStructure || '-';

                const rsiColor = (rsi > 70) ? 'red' : ((rsi < 30) ? 'green' : 'white');
                const trendColor = (trend === 'Up') ? 'lightgreen' : ((trend === 'Down') ? 'lightcoral' : 'gray');

                html += `<tr>
                    <td><strong>${symbol}</strong></td>
                    <td>${price}</td>
                    <td style="color:${rsiColor}">${rsi}</td>
                    <td>${chop}</td>
                    <td style="color:${trendColor}">${trend}</td>
                    <td>${smc}</td>
                </tr>`;
            }

            html += '</tbody></table>';

            const firstSymbol = Object.keys(results)[0];
            if (firstSymbol) {
                html += `<h3>Sample Data (${firstSymbol} - Last 5 Candles)</h3>`;
                html += `<pre>${JSON.stringify(results[firstSymbol].slice(-5), null, 2)}</pre>`;
            }

            container.innerHTML = html;
        }

        // =============================================
        // Show Detailed Check Chart (Multi-Chart Support)
        // =============================================
        function updateChartLayout() {
            const cols = document.getElementById('chartColumns').value;
            const container = document.getElementById('chartsContainer');
            if (container) {
                container.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
            }
        }

        function clearAllCharts() {
            document.getElementById('chartsContainer').innerHTML = '';
            document.getElementById('checkChartPanel').style.display = 'none';
            // Dispose all roots
            Object.values(detailedChartsRoots).forEach(roots => roots.forEach(r => r.dispose()));
            detailedChartsRoots = {};

            // Remove selection highlight
            document.querySelectorAll('.asset-card').forEach(el => el.classList.remove('selected-asset'));
        }

        function closeChart(symbol) {
            const card = document.getElementById(`chart-card-${symbol}`);
            if (card) card.remove();
            // Dispose roots for this symbol
            if (detailedChartsRoots[symbol]) {
                detailedChartsRoots[symbol].forEach(r => r.dispose());
                delete detailedChartsRoots[symbol];
            }

            // Remove selection highlight from specific asset
            const assetCard = document.getElementById(`asset-card-${symbol}`);
            if (assetCard) assetCard.classList.remove('selected-asset');

            // Hide panel if empty
            if (document.getElementById('chartsContainer').children.length === 0) {
                document.getElementById('checkChartPanel').style.display = 'none';
            }
        }

        function showCheckChart(symbol) {
            const data = globalAnalysisResults[symbol];
            if (!data || data.length === 0) {
                alert("No data available for " + symbol);
                return;
            }

            // check if exists
            if (document.getElementById(`chart-card-${symbol}`)) {
                document.getElementById(`chart-card-${symbol}`).scrollIntoView({ behavior: "smooth" });
                return;
            }

            document.getElementById('checkChartPanel').style.display = 'block';

            // Highlight selected asset in list
            const assetCard = document.getElementById(`asset-card-${symbol}`);
            if (assetCard) assetCard.classList.add('selected-asset');

            // Set initial layout from dropdown
            updateChartLayout();

            const container = document.getElementById('chartsContainer');

            // 1. Create Card HTML
            const card = document.createElement('div');
            card.id = `chart-card-${symbol}`;
            card.style.background = '#1e1e2e';
            card.style.border = '1px solid #569cd6';
            card.style.borderRadius = '10px';
            card.style.padding = '20px';
            card.style.position = 'relative';

            // Determine gauge style
            const gaugeStyle = document.querySelector('input[name="gaugeStyle"]:checked') ? document.querySelector('input[name="gaugeStyle"]:checked').value : 'standard';

            const meterId1 = `detail-meter-ci-${symbol}`;
            const meterId2 = `detail-meter-bb-${symbol}`;

            let gaugeContent = '';
            if (gaugeStyle === 'amcharts') {
                gaugeContent = `
                    <div style="display:flex; justify-content:center; gap:20px; margin-bottom:15px; background:rgba(255,255,255,0.03); padding:10px; border-radius:8px;">
                         <div style="width:250px; height:180px;"><div id="${meterId1}" style="width:100%; height:100%;"></div></div>
                         <div style="width:250px; height:180px;"><div id="${meterId2}" style="width:100%; height:100%;"></div></div>
                    </div>`;
            } else {
                gaugeContent = `
                    <div style="display:flex; justify-content:center; gap:20px; margin-bottom:15px; background:rgba(255,255,255,0.03); padding:10px; border-radius:8px;">
                         <div style="width:160px; height:100px;"><canvas id="${meterId1}" style="width:100%; height:100%;"></canvas></div>
                         <div style="width:160px; height:100px;"><canvas id="${meterId2}" style="width:100%; height:100%;"></canvas></div>
                    </div>`;
            }

            // Get Status Info
            const last = data[data.length - 1];
            const statusInfoObj = {
                accuStatus: last.accuStatus,
                close: last.close,
                bbUpper25: last.bbUpper25,
                bbLower25: last.bbLower25
            };
            const { statusBadge, statusDesc } = getAssetStatus(statusInfoObj);

            card.innerHTML = `
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px; border-bottom:1px solid #333; padding-bottom:10px;">
                    <div>
                        <h2 style="color:#569cd6; margin:0; display:inline-block; margin-right:10px;">${symbol} Analysis</h2>
                        ${statusBadge}
                    </div>
                    <button onclick="closeChart('${symbol}')" style="background:#555; padding:5px 15px; border-radius:4px; border:none; color:white; cursor:pointer;">Close ‚ùå</button>
                </div>
                ${gaugeContent}
                <div style="margin-bottom: 10px; text-align:center;">
                    ${statusDesc}
                </div>
                <div id="chart-div-${symbol}" style="height:450px; width:100%; padding-bottom:10px;"></div>
            `;

            container.prepend(card); // Add to top

            // 2. Initialize Meters
            // const last = data[data.length - 1]; // Already declared
            detailedChartsRoots[symbol] = []; // Init disposal list

            requestAnimationFrame(() => {
                if (gaugeStyle === 'amcharts') {
                    // CI Meter
                    const r1 = createAmChartsGaugeV2(meterId1, last.choppyIndicator, 0, 100, [
                        { startValue: 0, endValue: 38.2, color: '#22c55e' },
                        { startValue: 38.2, endValue: 61.8, color: '#eab308' },
                        { startValue: 61.8, endValue: 100, color: '#ef4444' }
                    ], 'CHOPPY');
                    if (r1) detailedChartsRoots[symbol].push(r1);

                    // BB Pos Meter
                    const range = last.bbUpper - last.bbLower;
                    let bbPosPct = (range === 0) ? 50 : ((last.close - last.bbLower) / range) * 100;
                    bbPosPct = Math.max(0, Math.min(100, bbPosPct));

                    const r2 = createAmChartsGaugeV2(meterId2, bbPosPct, 0, 100, [
                        { startValue: 0, endValue: 25, color: '#ef4444' },
                        { startValue: 25, endValue: 40, color: '#eab308' },
                        { startValue: 40, endValue: 60, color: '#22c55e' },
                        { startValue: 60, endValue: 75, color: '#eab308' },
                        { startValue: 75, endValue: 100, color: '#ef4444' }
                    ], 'BB POS %');
                    if (r2) detailedChartsRoots[symbol].push(r2);

                } else {
                    new ChoppyMeter(meterId1, {
                        title: 'CHOPPINESS',
                        zones: [
                            { from: 0, to: 38.2, color: '#4caf50' },
                            { from: 38.2, to: 61.8, color: '#ffeb3b' },
                            { from: 61.8, to: 100, color: '#f44336' }
                        ]
                    }).setValue(last.choppyIndicator);

                    const range = last.bbUpper - last.bbLower;
                    let bbPosPct = (range === 0) ? 50 : ((last.close - last.bbLower) / range) * 100;
                    bbPosPct = Math.max(0, Math.min(100, bbPosPct));

                    new ChoppyMeter(meterId2, {
                        title: 'BB POS %',
                        zones: [
                            { from: 0, to: 25, color: '#f44336' },
                            { from: 25, to: 40, color: '#ffeb3b' },
                            { from: 40, to: 60, color: '#4caf50' },
                            { from: 60, to: 75, color: '#ffeb3b' },
                            { from: 75, to: 100, color: '#f44336' }
                        ]
                    }).setValue(bbPosPct);
                }
            });


            // 3. Initialize Chart
            const chartDiv = document.getElementById(`chart-div-${symbol}`);
            // Create Chart
            const chart = LightweightCharts.createChart(chartDiv, {
                width: chartDiv.clientWidth,
                height: 450,
                layout: {
                    background: { color: '#1e1e2e' },
                    textColor: '#d4d4d4',
                    fontFamily: "'Roboto', 'Segoe UI', 'Arial', sans-serif",
                    fontSize: 12,
                },
                grid: {
                    vertLines: { color: '#2b2b43' },
                    horzLines: { color: '#2b2b43' },
                },
                timeScale: {
                    timeVisible: true,
                    secondsVisible: true,
                    borderVisible: true,
                    borderColor: '#485c7b',
                    rightOffset: 50, // Increase space slightly more as requested "middle"
                    fixLeftEdge: true,
                    lockVisibleTimeRangeOnResize: true,
                    barSpacing: 6,
                    minBarSpacing: 4,
                    // Fix Axis Time Label
                    tickMarkFormatter: (time, tickMarkType, locale) => {
                        return new Date(time * 1000).toLocaleTimeString('th-TH', {
                            timeZone: 'Asia/Bangkok',
                            hour: '2-digit',
                            minute: '2-digit',
                            hour12: false
                        });
                    },
                },
                rightPriceScale: {
                    borderColor: '#485c7b',
                },
                localization: {
                    dateFormat: 'yyyy-MM-dd',
                    timeFormatter: (timestamp) => {
                        return new Date(timestamp * 1000).toLocaleString('th-TH', {
                            timeZone: 'Asia/Bangkok',
                            year: 'numeric',
                            month: '2-digit',
                            day: '2-digit',
                            hour: '2-digit',
                            minute: '2-digit',
                            second: '2-digit',
                            hour12: false
                        });
                    }
                },
            });

            // Add Series
            const candleSeries = chart.addCandlestickSeries({
                upColor: '#22c55e',
                downColor: '#ef4444',
                borderVisible: false,
                wickUpColor: '#22c55e',
                wickDownColor: '#ef4444',
            });

            const bbUpperSeries = chart.addLineSeries({ color: 'rgba(34, 197, 94, 0.5)', lineWidth: 1, lineStyle: 2, title: 'BB Upper' });
            const bbLowerSeries = chart.addLineSeries({ color: 'rgba(34, 197, 94, 0.5)', lineWidth: 1, lineStyle: 2, title: 'BB Lower' });
            const bbMiddleSeries = chart.addLineSeries({ color: '#ffd700', lineWidth: 1, title: 'BB Middle' });

            const bbUpper25Series = chart.addLineSeries({ color: 'rgba(239, 68, 68, 0.7)', lineWidth: 1, lineStyle: 3, title: 'Upper 2.5' });
            const bbLower25Series = chart.addLineSeries({ color: 'rgba(239, 68, 68, 0.7)', lineWidth: 1, lineStyle: 3, title: 'Lower 2.5' });

            const emaSeries = chart.addLineSeries({ color: '#3b82f6', lineWidth: 1, title: 'EMA Med' });

            // Prepare Data (last 300 candles)
            const limit = 300;
            const slicedData = data.slice(-limit);

            const candleData = [];
            const bbUpperData = [];
            const bbLowerData = [];
            const bbMiddleData = [];
            const bbUpper25Data = [];
            const bbLower25Data = [];
            const emaData = [];

            // Lightweight Chart requires unique, sorted time. Data should be sorted by time already.
            // Adjust data to be in local time (Thai Time mostly matches user's local)
            // Lightweight charts expects Unix Timestamp (seconds). 
            // The timeFormatter in localization handles the display.
            slicedData.forEach(d => {
                // Convert time to UNIX timestamp (seconds)
                let time = d.candletime;
                if (time > 10000000000) time = Math.floor(time / 1000); // Convert ms to s if needed

                // Shift data slightly to center? No, standard centering is done via scroll/visible range.
                // We will use setVisibleLogicalRange later or just fitContent.

                candleData.push({ time: time, open: d.open, high: d.high, low: d.low, close: d.close });

                if (d.bbUpper !== null) bbUpperData.push({ time, value: d.bbUpper });
                if (d.bbLower !== null) bbLowerData.push({ time, value: d.bbLower });
                if (d.bbMiddle !== null) bbMiddleData.push({ time, value: d.bbMiddle });

                if (d.bbUpper25 !== null) bbUpper25Data.push({ time, value: d.bbUpper25 });
                if (d.bbLower25 !== null) bbLower25Data.push({ time, value: d.bbLower25 });

                if (d.emaMediumValue !== null) emaData.push({ time, value: d.emaMediumValue });
            });

            candleSeries.setData(candleData);
            bbUpperSeries.setData(bbUpperData);
            bbLowerSeries.setData(bbLowerData);
            bbMiddleSeries.setData(bbMiddleData);
            bbUpper25Series.setData(bbUpper25Data);
            bbLower25Series.setData(bbLower25Data);
            emaSeries.setData(emaData);

            // Center the chart logic
            // fitContent() makes it all visible. To put latest in "middle" or specific focus:
            // We can rely on rightOffset (added in options) to give breathing room.
            // Or manually set visible range.
            chart.timeScale().fitContent();

            // Apply Right Offset again to ensure breathing room on right
            chart.timeScale().scrollToPosition(0, false); // Scroll to real-time end

            // To make "latest come to middle", we basically need large right offset or zoom.
            // Let's try to just give a good right spacing as requested "latest to middle" is usually "latest + space".
            chart.timeScale().applyOptions({ rightOffset: 50 });

            // Handle Resize
            new ResizeObserver(() => {
                if (chartDiv && chartDiv.clientWidth) {
                    chart.resize(chartDiv.clientWidth, 450);
                }
            }).observe(chartDiv);
        }

        // =============================================
        // AmCharts Gauge Implementation
        // =============================================
        function createAmChartsGauge(elementId, value, min, max, zones, title) {
            // Check if element exists
            if (!document.getElementById(elementId)) return null;

            // Create root
            var root = am5.Root.new(elementId);
            // amChartsRoots.push(root); // Removed auto-push

            // Set themes
            root.setThemes([
                am5themes_Animated.new(root)
            ]);

            // Create chart
            var chart = root.container.children.push(am5radar.RadarChart.new(root, {
                panX: false,
                panY: false,
                startAngle: 180,
                endAngle: 360,
                innerRadius: -20
            }));

            // Axis
            var axisRenderer = am5radar.AxisRendererCircular.new(root, {
                innerRadius: -10,
                radius: am5.percent(100)
            });

            axisRenderer.labels.template.setAll({
                visible: false
            });
            axisRenderer.grid.template.setAll({
                visible: false
            });


            var axis = chart.xAxes.push(am5xy.ValueAxis.new(root, {
                maxDeviation: 0,
                min: min,
                max: max,
                renderer: axisRenderer,
                strictMinMax: true
            }));

            // Axis Ranges (Bands)
            zones.forEach(zone => {
                var rangeDataItem = axis.makeDataItem({
                    value: zone.startValue,
                    endValue: zone.endValue
                });
                var range = axis.createAxisRange(rangeDataItem);

                range.get("axisFill").setAll({
                    fill: am5.color(zone.color),
                    fillOpacity: 0.8,
                    visible: true,
                    innerRadius: -20,
                    cornerRadius: 0
                });
            });

            // Hand (Needle)
            var handDataItem = axis.makeDataItem({
                value: value
            });

            var hand = axis.createAxisRange(handDataItem);
            hand.get("grid").set("visible", false);

            var clockHand = am5radar.ClockHand.new(root, {
                pinRadius: 10,
                radius: am5.percent(90),
                bottomWidth: 10
            });

            clockHand.pin.setAll({
                fill: am5.color(0xFFD700),
                stroke: am5.color(0x1e1e1e)
            });

            clockHand.hand.setAll({
                fill: am5.color(0xFFD700),
                stroke: am5.color(0x1e1e1e),
                y: am5.percent(-10)
            });

            handDataItem.set("bullet", am5xy.AxisBullet.new(root, {
                sprite: clockHand
            }));

            // Value Label
            var label = chart.radarContainer.children.push(am5.Label.new(root, {
                fontSize: 24,
                fontWeight: "bold",
                centerX: am5.percent(50),
                centerY: am5.percent(100),
                x: am5.percent(50),
                y: am5.percent(90),
                text: value.toFixed(1),
                fill: am5.color(0xffffff)
            }));

            // Title Label
            var titleLabel = chart.radarContainer.children.push(am5.Label.new(root, {
                fontSize: 12,
                centerX: am5.percent(50),
                x: am5.percent(50),
                y: am5.percent(110),
                text: title,
                fill: am5.color(0x888888)
            }));

            // Animate
            handDataItem.animate({
                key: "value",
                to: value,
                duration: 2000,
                easing: am5.ease.out(am5.ease.cubic)
            });

            return root;
        }
        // =============================================
        // AmCharts Gauge Implementation (Adapted from guageAmChart.html)
        // =============================================
        function createAmChartsGaugeV2(elementId, value, min, max, zones, title) {
            // Check if element exists
            if (!document.getElementById(elementId)) return null;

            // Create root
            var root = am5.Root.new(elementId);
            // amChartsRoots.push(root); // Removed auto-push

            // Set themes
            root.setThemes([
                am5themes_Animated.new(root)
            ]);

            // Create chart
            var chart = root.container.children.push(am5radar.RadarChart.new(root, {
                panX: false,
                panY: false,
                startAngle: 180,
                endAngle: 360
            }));

            // Create axis and its renderer
            var axisRenderer = am5radar.AxisRendererCircular.new(root, {
                innerRadius: -20
            });

            // Enable grid lines
            axisRenderer.grid.template.setAll({
                stroke: root.interfaceColors.get("background"),
                visible: true,
                strokeOpacity: 0.8
            });

            // Disable default axis labels (numbers)
            axisRenderer.labels.template.setAll({
                visible: false
            });

            var xAxis = chart.xAxes.push(am5xy.ValueAxis.new(root, {
                maxDeviation: 0,
                min: min,
                max: max,
                strictMinMax: true,
                renderer: axisRenderer
            }));

            // Add clock hand (Needle)
            var axisDataItem = xAxis.makeDataItem({});

            // Initial value for animation
            axisDataItem.set("value", min);

            var clockHand = am5radar.ClockHand.new(root, {
                pinRadius: am5.percent(20),
                radius: am5.percent(100),
                bottomWidth: 10
            });

            // Initial color (black)
            clockHand.pin.setAll({ fill: am5.color(0x000000) });
            clockHand.hand.setAll({ fill: am5.color(0x000000) });

            var bullet = axisDataItem.set("bullet", am5xy.AxisBullet.new(root, {
                sprite: clockHand
            }));

            xAxis.createAxisRange(axisDataItem);

            // Label for value (Center)
            var label = chart.radarContainer.children.push(am5.Label.new(root, {
                fill: am5.color(0xffffff),
                centerX: am5.percent(50),
                textAlign: "center",
                centerY: am5.percent(0), // Align top to center point
                fontSize: "2em",
                fontWeight: "bold",
                dy: 20, // Move down
                text: value.toFixed(1)
            }));

            // Label for Title
            chart.radarContainer.children.push(am5.Label.new(root, {
                fill: am5.color(0xcccccc), // Brighter grey
                centerX: am5.percent(50),
                textAlign: "center",
                centerY: am5.percent(0),
                dy: 60, // Move below value
                fontSize: "0.9em",
                text: title
            }));

            // Ranges (Bands)
            zones.forEach(zone => {
                var axisRange = xAxis.createAxisRange(xAxis.makeDataItem({}));

                axisRange.setAll({
                    value: zone.startValue,
                    endValue: zone.endValue
                });

                axisRange.get("axisFill").setAll({
                    visible: true,
                    fill: am5.color(zone.color),
                    fillOpacity: 1 // Fully opaque for brighter colors
                });

                // Labels inside bands (Optional - logic from example)
                // Only showing if label is provided (e.g. for CI meter)
                if (zone.label) {
                    axisRange.get("label").setAll({
                        text: zone.label,
                        inside: true,
                        radius: 5,
                        fontSize: "0.9em",
                        fill: am5.color(0xffffff)
                    });
                }
            });

            // Animate
            axisDataItem.animate({
                key: "value",
                to: value,
                duration: 2000,
                easing: am5.ease.out(am5.ease.cubic)
            });

            return root;
        }

    </script>
</body>

</html>